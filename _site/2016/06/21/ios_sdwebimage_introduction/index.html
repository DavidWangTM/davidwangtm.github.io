<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="baidu-site-verification" content="6o2YzUB1JR"/>
    <meta name="description" content="爱唱歌健身的程序员 | 王伟达，Web & algorithm Lover，Server Enginee | 这里是 @王伟达 的个人博客，期待和你一起学习成长。">
    <meta name="keyword" content="DavidWangTM, 王伟达, 技术, 软件, 互联网, Mac, 算法, Linux, blog ,php ,android, ios">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        IOS 开源库讲解篇二
            -
            DavidWang's Blog | 王伟达的博客
        
    </title>

    <link rel="canonical" href="http://DavidWangTM.github.io/2016/06/21/ios_sdwebimage_introduction/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href=" /css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href=" /css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href=" /css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">DavidWang's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/portfolio/">Portfolio</a>
                    </li>
                    
                    <li>
                        <a href="/markdown/">markdown</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-e2e-ux.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-e2e-ux.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#ios" title="ios">ios</a>
                        
                        <a class="tag" href="/tags/#Xcode" title="Xcode">Xcode</a>
                        
                        <a class="tag" href="/tags/#SDWebImage" title="SDWebImage">SDWebImage</a>
                        
                    </div>
                    <h1>IOS 开源库讲解篇二</h1>
                    
                    
                    <h2 class="subheading">SDWebImage 源码解析</h2>
                    
                    <span class="meta">Posted by DavidWang on June 21, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h3 id="section">前言</h3>

<p><code class="highlighter-rouge">SDWebImage</code>是iOS开发中十分流行的库，大多数的开发者在下载图片或者加载网络图片并且本地缓存的时候，都会用这个框架。这个框架相对来说，源代码还是比较少的。</p>

<p>先介绍类的整体架构关系，先有一个宏观的认识。然后讲解<code class="highlighter-rouge">sd_setImageWithURL</code>的加载逻辑，因为这是SDWebImage最核心的，也是很多面试会问到的。接下来会介绍Image的解码，然后讲解缓存处理。最后再讲解API设计方式,以及其他我认为有用的。</p>

<h3 id="section-1">整体架构关系</h3>

<h4 id="section-2">定义通用宏和方法</h4>

<ul>
  <li><code class="highlighter-rouge">SDWebImageCompat</code>宏定义和C语言的一些工具方法</li>
  <li><code class="highlighter-rouge">SDWebImageOperation</code>，定义通用的Operation协议，主要就是一个方法，cancel。从而在cancel的时候，可以面向协议编程。</li>
</ul>

<h4 id="section-3">下载</h4>

<ul>
  <li><code class="highlighter-rouge">SDWebImageDownloader</code> 实际的下载功能和配置提供者，使用了<strong>单例</strong>的设计模式.</li>
  <li><code class="highlighter-rouge">SDWebImageDownloaderOperation</code>，继承自<code class="highlighter-rouge">NSOperation</code>，是一个异步的<code class="highlighter-rouge">NSOperation</code>,封装了<code class="highlighter-rouge">NSURLConnection</code>进行实际的下载任务.</li>
</ul>

<h4 id="section-4">缓存处理</h4>

<ul>
  <li><code class="highlighter-rouge">AutoPurgeCache,NSCache</code>的子类，用于内存<code class="highlighter-rouge">cache</code>，会在收到内存警告的时候，自动清空.</li>
  <li><code class="highlighter-rouge">SDImageCache</code>，实际处理内存<code class="highlighter-rouge">cache</code>和磁盘<code class="highlighter-rouge">cache</code>.</li>
</ul>

<h4 id="section-5">功能类</h4>

<ul>
  <li><code class="highlighter-rouge">SDWebImageManager</code>,宏观的从整体上管理整个框架的类.</li>
  <li><code class="highlighter-rouge">SDWebImageDecoder</code>，图片的解码类，后面会详细的讲解如何解码的.</li>
  <li><code class="highlighter-rouge">SDWebImagePrefetcher</code>，图片的预加载管理.</li>
</ul>

<h4 id="section-6">类别</h4>

<ul>
  <li>类别用来为UIView和UIImageView等”添加”属性来存储必要的信息，同时暴露出接口，进行实际的操作。</li>
</ul>

<h4 id="tips">Tips：</h4>

<ul>
  <li>用类别来提供接口往往是最方便的，因为用户只需要import这个文件，就可以像使用原生SDK那样去开发，不需要修改原有的什么代码</li>
  <li>面向对象开发有一个原则是－单一功能原则，所以不管是在开发一个Lib或者开发App的时候，尽量保证各个模块之前功能单一，这样会降低耦合。</li>
</ul>

<h3 id="sdsetimagewithurl">sd_setImageWithURL的加载逻辑</h3>

<h4 id="section-7">1. 取消当前正在加载的图片</h4>

<p><code class="highlighter-rouge">[self sd_cancelCurrentImageLoad];</code></p>

<p>这个方法的实际调用源代码如下，其中key是UIImageViewImageLoad.</p>

<p><strong>Tips：operationDictionary是通过Runtime为UIView”添加”的属性</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sd_cancelImageLoadOperationWithKey</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span> <span class="p">{</span>
     <span class="c1">//用一个字典来存储当前的加载operation
</span>    <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">operationDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">operationDictionary</span><span class="p">];</span>
    <span class="n">id</span> <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span><span class="n">operationDictionary</span> <span class="nf">objectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
    <span class="c1">//两种类型，帧类型的的gif是多个operation，静态图是一个operaiton
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">operations</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">operations</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">NSArray</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span> <span class="n">operation</span> <span class="k">in</span> <span class="n">operations</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
                    <span class="p">[</span><span class="n">operation</span> <span class="nf">cancel</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">operations</span> <span class="nf">conformsToProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">SDWebImageOperation</span><span class="p">)]){</span>
            <span class="c1">//这里属于面向协议编程，不关心具体的类，只关心遵守某个协议
</span>            <span class="p">[(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">operations</span> <span class="nf">cancel</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="c1">//删除对应的key
</span>        <span class="p">[</span><span class="n">operationDictionary</span> <span class="nf">removeObjectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="placeholderplaceholder">2. 如果有PlaceHolder，设置placeHolder</h4>

<p><code class="highlighter-rouge">
   if (!(options &amp; SDWebImageDelayPlaceholder)) {
        dispatch_main_async_safe(^{
            self.image = placeholder;
        });
    }
</code></p>

<p>这里的dispatch_main_async_safe是一个宏定义，会检查调用是否在主线程上，如果在主线程就直接调用，后台线程会用gcd切换到主线程</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#define dispatch_main_async_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_async(dispatch_get_main_queue(), block);\
    }
</code></pre>
</div>

<h4 id="sdimagecache">3. 根据SDImageCache来查缓存，看看是否有图片</h4>

<p>查看缓存的是这个方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {//异步返回查询的结果}
</code></pre>
</div>

<p>这块感觉代码优点难懂，其实这是执行了一个方法queryDiskCacheForKey:key，返回一个NSOperation,之所以这样，是因为从磁盘或者内存查询的过程是异步的，后面可能需要cancel，所以这样做。</p>

<p>我们再看看queryDiskCacheForKey:key这个方法是怎么实现的？</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock {
    //输入检查，这里省略掉
    //先检查磁盘缓存
    UIImage *image = [self imageFromMemoryCacheForKey:key];
    if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }
    //检查磁盘缓存
    NSOperation *operation = [NSOperation new];
    dispatch_async(self.ioQueue, ^{//切换到io队列上，进行磁盘操作
            //省略中间检查代码
            //回归到主线程行，进行doneBlock操作
            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
        }
    });
    return operation;
}
</code></pre>
</div>

<h4 id="section-8">4. 创建下载任务</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
 //这里是下载完成后的回调，没什么要讲解的，简单来说就是image下载成功，就wself.image = image;[wself setNeedsLayout];,下载失败仍然显示placeHolder。然后调用completion block回调。
        }];
//记录下来当前的下载，方便后面取消
[self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"];
</code></pre>
</div>

<p>接下来，我们来看看实际的下载operation是什么样子的 
也就是这个方法</p>

<p><a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m">-(id)downloadImageWithURL:options:progress:completed:</a></p>

<h4 id="block">5－1,由于有各种各样的block回调，例如下载进度的回调，完成的回调，所以需要一个数据结构来存储这些回调</h4>

<p>所以，这个方法中，首先调用以下方法来存储回调</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
//...
}
</code></pre>
</div>

<p>其中，用来存储回调的数据结构是一个NSMutableDictionary,其中key是图片的url，value是回调的数组 
举个例子，存储后应该是这样的，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@{
        @"http://iamgeurl":[
                            @{
                                @"progress":progressBlock1,
                                @"completed":completedBlock1,
                            },
                            @{
                                @"progress":progressBlock2,
                                @"completed":completedBlock2,
                              },
                           ],
            //其他
}
</code></pre>
</div>
<p>** Tips：注意，对于同一个URL，在第二次调用addProgressCallback:progressBlock用的时候，并不会执行createCallback，也就是说，保证一个URL在多次下载的时候，只进行多次回调，而不会进行多次网络请求**</p>

<p>如果是我，可能更愿意用一个对象来存储这些block回调，觉得这个数据结构有点复杂，很难维护</p>

<h4 id="urlsdsetimagesdwebimagedownloaderoperation">5－2,对于同一个url，在第一次调用sd_setImage的时候进行，创建网络请求<code class="highlighter-rouge">SDWebImageDownloaderOperation</code>。</h4>

<p>创建的方法是这个</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[[wself.operationClass alloc] initWithRequest:request
                                      options:options
                                     progress:^(NSInteger receivedSize, NSInteger expectedSize){//Progress 回调}
                                     completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished){//Completion回调}
                                     cancelled:^{//Cancel 回调}
</code></pre>
</div>

<p>在看看Progress回调</p>

<div class="highlighter-rouge"><pre class="highlight"><code> //Block中强引用sself（weakself）,保证在执行结束前不会被释放
 SDWebImageDownloader *sself = wself; 
 //如果weakself已经为nil，此时已经释放了，所以直接放回
 if (!sself) return;
 //用__block来修饰callbacksForURL，保证在能在block中修改这个变量
 __block NSArray *callbacksForURL;
 //在队列`barrierQueue`里同步捕获callBack
 dispatch_sync(sself.barrierQueue, ^{
     callbacksForURL = [sself.URLCallbacks[url] copy];
 });
 for (NSDictionary *callbacks in callbacksForURL) {
//异步切换到主线程上进行回调
   dispatch_async(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         if (callback) callback(receivedSize, expectedSize);
     });
 }                             
</code></pre>
</div>

<p>completion回调和progress类似，不再赘述。 
再看看cancel block的处理</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SDWebImageDownloader *sself = wself;
if (!sself) return;
//阻碍barrierQueue,
dispatch_barrier_async(sself.barrierQueue, ^{
    [sself.URLCallbacks removeObjectForKey:url];
});
</code></pre>
</div>

<p><strong>Tips:这里为什么要用<code class="highlighter-rouge">dispatch_barrier_async</code>呢？因为</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>_barrierQueue = dispatch_queue_create("com.hackemist.SDWebImageDownloaderBarrierQueue", DISPATCH_QUEUE_CONCURRENT);
</code></pre>
</div>
<p>_barrierQueue是个并行队列，意味着队列上的任务可以并行执行。用<code class="highlighter-rouge">dispatch_barrier_async</code>来保证后续提交的block等待当前的<code class="highlighter-rouge">dispatch_barrier_asyncblock</code>执行完毕后再执行。</p>

<p>Tips：</p>

<p>用这么多GCD是为了保证线程安全
再简单提一下<code class="highlighter-rouge">dispatch_barrier_async</code>的用法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Calls to this function always return immediately after the block has been submitted and never wait for the block to be invoked. When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes.
</code></pre>
</div>

<h4 id="imageview">4. 下载图片完成后，根据需要图片解码和处理图片格式，回调给Imageview</h4>

<div class="highlighter-rouge"><pre class="highlight"><code> UIImage *image = [UIImage sd_imageWithData:self.imageData];
            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
            image = [self scaledImageForKey:key image:image];

            // Do not force decoding animated GIFs
            if (!image.images) {
                if (self.shouldDecompressImages) {
                    image = [UIImage decodedImageWithImage:image];
                }
            }
</code></pre>
</div>

<p>总结下整个调用过程</p>

<ul>
  <li>取消上一次调用</li>
  <li>设置placeHolder</li>
  <li>保存回调block</li>
  <li>cache查询是否已经下载过了，先检查内存，后检查磁盘</li>
  <li>利用NSURLConnection来下载图片，根据需要解码，回调给imageview，存储到缓存</li>
</ul>

<h3 id="section-9">线程管理</h3>

<p>整个SDWebImage一共有四个队列</p>

<ul>
  <li>Main queue,主队列，在这个队列上进行UIKit对象的更新，发送notification</li>
  <li>barrierQueue，并行队列，在这个队列上统一处理3-1中的数据回调，为了保证线程安全，一致使用dispatch_barrier_sync</li>
  <li>ioQueue，用在图片的磁盘操作</li>
  <li>downloadQueue（NSOperationQueue），用来全局的管理下载的任务</li>
</ul>

<h3 id="section-10">图片解码</h3>

<p>传统的UIImage进行解码都是在主线程上进行的，比如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>UIImage * image = [UIImage imageNamed:@"123.jpg"]
self.imageView.image = image;
</code></pre>
</div>
<p>在这个时候，图片其实并没有解码。而是，当图片实际需要显示到屏幕上的时候，CPU才会进行解码，绘制成纹理什么的，交给GPU渲染。这其实是很占用主线程CPU时间的，而众所周知，主线程的时间真的很宝贵</p>

<p>现在，我们看看SDWebImage是如何在后台进行解码的 
代码来自于这个原文件<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDecoder.m">SDWebImageDecoder</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (UIImage *)decodedImageWithImage:(UIImage *)image {
    if (image == nil) { 
        return nil;
    }

    @autoreleasepool{
        //Gif不用解码，直接返回
        if (image.images != nil) {
            return image;
        }
        CGImageRef imageRef = image.CGImage
        ;
        CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef);
        BOOL anyAlpha = (alpha == kCGImageAlphaFirst ||
                         alpha == kCGImageAlphaLast ||
                         alpha == kCGImageAlphaPremultipliedFirst ||
                         alpha == kCGImageAlphaPremultipliedLast);
        if (anyAlpha) {
        //有Alpha通道，直接返回
            return image;
        }
        //获得Color Space
        CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));
        CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);

        BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown ||
                                      imageColorSpaceModel == kCGColorSpaceModelMonochrome ||
                                      imageColorSpaceModel == kCGColorSpaceModelCMYK ||
                                      imageColorSpaceModel == kCGColorSpaceModelIndexed);
        if (unsupportedColorSpace) {
            colorspaceRef = CGColorSpaceCreateDeviceRGB();
        }

        size_t width = CGImageGetWidth(imageRef);
        size_t height = CGImageGetHeight(imageRef);
        NSUInteger bytesPerPixel = 4;
        NSUInteger bytesPerRow = bytesPerPixel * width;
        NSUInteger bitsPerComponent = 8;
        //创建bitmapContext
        CGContextRef context = CGBitmapContextCreate(NULL,
                                                     width,
                                                     height,
                                                     bitsPerComponent,
                                                     bytesPerRow,
                                                     colorspaceRef,
                                                     kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);

        // 绘制Image到Context中，强制解码
        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);
        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);
        UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha
                                                         scale:image.scale
                                                   orientation:image.imageOrientation];

        if (unsupportedColorSpace) {
            CGColorSpaceRelease(colorspaceRef);
        }

        CGContextRelease(context);
        CGImageRelease(imageRefWithoutAlpha);

        return imageWithoutAlpha;
    }
}
</code></pre>
</div>

<h3 id="section-11">缓存处理</h3>

<p>整个缓存处理的类都在<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDImageCache.m">SDImageCache</a>文件中，其中缓存又包括两个方面，</p>

<ul>
  <li>内存缓存</li>
  <li>磁盘缓存</li>
</ul>

<p>其中，内存缓存采用了NSCache的子类<code class="highlighter-rouge">AutoPurgeCache</code>，</p>

<p>AutoPurgeCache 
只是对NSCache添加了在收到内存警告通知<code class="highlighter-rouge">UIApplicationDidReceiveMemoryWarningNotification</code>的时候自动<code class="highlighter-rouge">removeAllObjects</code></p>

<p>再看看磁盘缓存是如何做的？ 
磁盘缓存是基于文件系统的,也就是说图片是以普通文件的方式存储到沙盒里的。</p>

<p>缓存的目录是啥？ 
默认的缓存目录是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Lbirary/Caches/default/com.hackemist.SDWebImageCache.default/
</code></pre>
</div>

<p>缓存的文件名称是对缓存的key求md5</p>

<p>何时自动清除过期图片？ 
在App关闭的时候</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(cleanDisk)
                                             name:UIApplicationWillTerminateNotification
                                           object:nil];
</code></pre>
</div>

<p>清除的逻辑很简单，获取文件的modify时间，然后比较下过期时间，如果过期了就删除。当磁盘缓存超过阈值后，根据最后访问的时间排序，删除最老的访问图片。</p>

<p>存储成什么格式？</p>

<p>见SDImageCache中，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//获取Alpha信息
int alphaInfo = CGImageGetAlphaInfo(image.CGImage);
BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||
                  alphaInfo == kCGImageAlphaNoneSkipFirst ||
                  alphaInfo == kCGImageAlphaNoneSkipLast);
BOOL imageIsPng = hasAlpha;

//如果又imageData，并且有png的前8个字节，根据NSData前8个字节来检查是否是png
if ([imageData length] &gt;= [kPNGSignatureData length]) {
    imageIsPng = ImageDataHasPNGPreffix(imageData);
}
//如果是Png，存储成png
if (imageIsPng) {
    data = UIImagePNGRepresentation(image);
}
else {
//否则存储称jpg
    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
}
</code></pre>
</div>

<h3 id="deprecatedapi">deprecated一个API</h3>

<p>只需要在方法后面，添加<code class="highlighter-rouge">__deprecated_msg</code>例如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (NSString *)contentTypeForImageData:(NSData *)data __deprecated_msg("Use `sd_contentTypeForImageData:`");
</code></pre>
</div>

<h3 id="section-12">条件编译</h3>

<p>这个在之前AsyncDisplayKit解析的文章里也提到过，这里再提一次</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0
//代码
#endif
</code></pre>
</div>
<p>又比如</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#if TARGET_OS_IOS 
//代码for iOS
#else
//代码for osx
#endif
</code></pre>
</div>

<p>就是条件编译，根据条件是否满足来让编译器编译这段代码。</p>

<p>**Tips：根据条件编译，可以为不同的版本的iOS做一些适配 **</p>

<h3 id="gif">如何实现Gif动图？</h3>

<p>本质上，使用这个iOS SDK提供的方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//传入一个Image数组，和动画的时间
animatedImage = [UIImage animatedImageWithImages:images duration:duration];
</code></pre>
</div>

<p>那么，如何解析Gif图片呢？ 
原理也比较简单，源代码在<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/UIImage+GIF.m">UIImage+GIF</a>.m中。利用<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CGImageSource/">CGImageSource</a>的一系列方法依次提取每一帧的图片和每一帧的图片间隔，然后用上文提到的API来实现Gif</p>

<p><strong>Tips：在ARC开启的时候，Foundation对象（CF开头）和CoreGraphics对象(CG开头）的一些对象仍然需要手动管理，例如</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);
//利用完毕
    CGImageRelease(image);
</code></pre>
</div>

<h3 id="section-13">获取图片的格式</h3>

<p>原文件<code class="highlighter-rouge">NSData+ImageContentType.m</code> ,代码不难，不做讲解了</p>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (NSString *)sd_contentTypeForImageData:(NSData *)data {
    uint8_t c;
    [data getBytes:&amp;c length:1];
    switch (c) {
        case 0xFF:
            return @"image/jpeg";
        case 0x89:
            return @"image/png";
        case 0x47:
            return @"image/gif";
        case 0x49:
        case 0x4D:
            return @"image/tiff";
        case 0x52:
            // R as RIFF for WEBP
            if ([data length] &lt; 12) {
                return nil;
            }

            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];
            if ([testString hasPrefix:@"RIFF"] &amp;&amp; [testString hasSuffix:@"WEBP"]) {
                return @"image/webp";
            }

            return nil;
    }
    return nil;
}
</code></pre>
</div>

<h3 id="section-14">预下载</h3>

<p>原文件<a href="https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImagePrefetcher.m">SDWebImagePrefetcher.m</a></p>

<p>可以看到，由于类的功能划分非常清楚，所以SDWebImagePrefetcher 的实现文件很简单，本质上只是用单例的设计模式，并且这个类保存了<code class="highlighter-rouge">SDWebImageManager</code>对象来进行的实际下载操作</p>

<h3 id="section-15">设计方式的一点理解</h3>

<ul>
  <li>整个框架的处理核心是SDWebImageManager类，而为了让使用者在使用的时候不必实例化这个类的一个对象，整个类采用了单利的设计模式。</li>
  <li>用block的方式，处理复杂的异步回调。用block的方式，在这里是要比代理来的简单直接的。如果用代理，那么上文讲解的sd_setImageWithURL的过程，将会有复杂的代理回调方法</li>
  <li>每个线程处理自己的独立任务。上文提到了，这个库一共有四个Queue</li>
  <li>面向协议编程。这个在SDWebImageOperation协议的体现上十分明显。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@protocol</span> <span class="nc">SDWebImageOperation</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cancel</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre>
</div>

<p>在使用的时候，只需关注协议的本身就可以了</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">([</span><span class="n">operations</span> <span class="nf">conformsToProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">SDWebImageOperation</span><span class="p">)]){</span>
     <span class="p">[(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">operations</span> <span class="nf">cancel</span><span class="p">];</span>
 <span class="p">}</span>
</code></pre>
</div>

<ul>
  <li>
    <p>用Category的方式提供接口,例如UIImageView+WebCache等，这样能最大程度的降低使用者的使用难度。</p>
  </li>
  <li>
    <p>单一功能原则,这个在上文提到了，每个类or文件负责单一的功能，方便独立测试和维护</p>
  </li>
</ul>

<p>最好的例子就是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>UIImage+GIF.h
UIImage+MultiFormat
UIImageView+HighlightedWebCache.h
UIImageView+WebCache.h
</code></pre>
</div>
<ul>
  <li>线程安全的保证。很明显，SDWebImage不能强求用户在某一个线程上调用，然后自己切换回主线程。所以你会看到类似这样的代码来保证线程安全</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>@synchronized (self) {}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>    dispatch_barrier_sync(sself.barrierQueue, ^{
                                                                callbacksForURL = [sself.URLCallbacks[url] copy];
                                                                if (finished) {
                                                                    [sself.URLCallbacks removeObjectForKey:url];
                                                                }
                                                            });
</code></pre>
</div>

<h3 id="section-16">总结</h3>

<p>SDWebImage相对来说，源代码没有那么多，建议大家好好研究下源代码。对图片的基础知识巩固，各种线程的处理方式，类的架构和API设计等都很有帮助。</p>


                <hr>

                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/06/20/ios_mantle_introduction/" data-toggle="tooltip" data-placement="top" title="IOS 开源库讲解篇一">
                        Previous<br>
                        <span>IOS 开源库讲解篇一</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/06/22/ios_core_animation1_introduction/" data-toggle="tooltip" data-placement="top" title="IOS 动画讲解一">
                        Next<br>
                        <span>IOS 动画讲解一</span>
                        </a>
                    </li>
                    
                </ul>


                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#Fedora" title="Fedora" rel="7">
                                    Fedora
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Markdown" title="Markdown" rel="3">
                                    Markdown
                                </a>
                            
        				
                            
                				<a href="/tags/#Leetcode" title="Leetcode" rel="12">
                                    Leetcode
                                </a>
                            
        				
                            
                				<a href="/tags/#Algorithm" title="Algorithm" rel="13">
                                    Algorithm
                                </a>
                            
        				
                            
                				<a href="/tags/#PHP" title="PHP" rel="2">
                                    PHP
                                </a>
                            
        				
                            
                				<a href="/tags/#MacOS" title="MacOS" rel="5">
                                    MacOS
                                </a>
                            
        				
                            
                				<a href="/tags/#Jekyll" title="Jekyll" rel="3">
                                    Jekyll
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Android" title="Android" rel="13">
                                    Android
                                </a>
                            
        				
                            
                				<a href="/tags/#ios" title="ios" rel="21">
                                    ios
                                </a>
                            
        				
                            
                				<a href="/tags/#Xcode" title="Xcode" rel="3">
                                    Xcode
                                </a>
                            
        				
                            
                				<a href="/tags/#Mac" title="Mac" rel="2">
                                    Mac
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#core-animation" title="core-animation" rel="15">
                                    core-animation
                                </a>
                            
        				
                            
                				<a href="/tags/#tomcat" title="tomcat" rel="2">
                                    tomcat
                                </a>
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "davidwang";
    var disqus_identifier = "/2016/06/21/ios_sdwebimage_introduction";
    var disqus_url = "http://DavidWangTM.github.io/2016/06/21/ios_sdwebimage_introduction/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/DavidWangTM">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/David_wang_xm">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/DavidWangTM">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; DavidWang's Blog 2016
                    <br>
                    Theme © <a href="http://davidwangtm.github.io">davidwangtm</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=davidwangtm&repo=davidwangtm.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- Highlight.js -->
<script>
    async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
        hljs.initHighlightingOnLoad();
    })
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>
<link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        // var $nav = document.querySelector("nav");
        // if($nav) FastClick.attach($nav);

        // global FastClick!!
        FastClick.attach(document.body);
    })
</script>

<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = '';
    var _gaDomain = 'DavidWangTM.github.io';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '2436e853445e53365067f8975c3f123b';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
