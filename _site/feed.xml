<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DavidWang&#39;s Blog</title>
    <description>爱唱歌健身的程序员 | 王伟达，Web &amp; algorithm Lover，Server Enginee | 这里是 @王伟达 的个人博客，期待和你一起学习成长。</description>
    <link>http://DavidWangTM.github.io/</link>
    <atom:link href="http://DavidWangTM.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 23 Jun 2016 11:42:02 +0800</pubDate>
    <lastBuildDate>Thu, 23 Jun 2016 11:42:02 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>IOS 动画讲解二</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;寄宿图&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。&lt;/p&gt;

&lt;h2 id=&quot;contents&quot;&gt;contents属性&lt;/h2&gt;
&lt;p&gt;CALayer 有一个属性叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;赋的不是CGImage，那么你得到的图层将是空白的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。&lt;/p&gt;

&lt;p&gt;头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。&lt;/p&gt;

&lt;p&gt;尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），它们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;layer.contents = (__bridge id)image.CGImage;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！&lt;/p&gt;

&lt;p&gt;让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;属性设置成图片。&lt;/p&gt;

&lt;p&gt;清单2.1 更新后的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@implementation ViewController

- (void)viewDidLoad
{
  [super viewDidLoad]; //load an image
  UIImage *image = [UIImage imageNamed:@&quot;Snowman.png&quot;];

  //add it directly to our view&#39;s layer
  self.layerView.layer.contents = (__bridge id)image.CGImage;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图表2.1 在UIView的宿主图层中显示一张图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.1.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;contentGravity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把&lt;code class=&quot;highlighter-rouge&quot;&gt;contentMode&lt;/code&gt;属性设置成更合适的值，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;view.contentMode = UIViewContentModeScaleAspectFit;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如&lt;code class=&quot;highlighter-rouge&quot;&gt;contentMode&lt;/code&gt;，对这些属性的操作其实是对对应图层的操作。&lt;/p&gt;

&lt;p&gt;CALayer与&lt;code class=&quot;highlighter-rouge&quot;&gt;contentMode&lt;/code&gt;对应的属性叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;可选的常量值有以下一些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;kCAGravityCenter&lt;/li&gt;
  &lt;li&gt;kCAGravityTop&lt;/li&gt;
  &lt;li&gt;kCAGravityBottom&lt;/li&gt;
  &lt;li&gt;kCAGravityLeft&lt;/li&gt;
  &lt;li&gt;kCAGravityRight&lt;/li&gt;
  &lt;li&gt;kCAGravityTopLeft&lt;/li&gt;
  &lt;li&gt;kCAGravityTopRight&lt;/li&gt;
  &lt;li&gt;kCAGravityBottomLeft&lt;/li&gt;
  &lt;li&gt;kCAGravityBottomRight&lt;/li&gt;
  &lt;li&gt;kCAGravityResize&lt;/li&gt;
  &lt;li&gt;kCAGravityResizeAspect&lt;/li&gt;
  &lt;li&gt;kCAGravityResizeAspectFill&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cotentMode&lt;/code&gt;一样，&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图2.2 可以看到结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.2.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.2 正确地设置&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;的值&lt;/p&gt;

&lt;h2 id=&quot;contentsscale&quot;&gt;contentsScale&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;由于设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;属性，所以它已经被拉伸以适应图层的边界。&lt;/p&gt;

&lt;p&gt;如果你只是单纯地想放大图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;图片，你可以通过使用图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;transform&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;affineTransform&lt;/code&gt;属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;的目的所在.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;属性）。UIView有一个类似功能但是非常少用到的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentScaleFactor&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。&lt;/p&gt;

&lt;p&gt;这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.3.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.3 用错误的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;属性显示Retina图片&lt;/p&gt;

&lt;p&gt;如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，它读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;来修复这个问题（如2.2清单），图2.4是结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@implementation ViewController

- (void)viewDidLoad
{
  [super viewDidLoad]; //load an image
  UIImage *image = [UIImage imageNamed:@&quot;Snowman.png&quot;]; //add it directly to our view&#39;s layer
  self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image
  self.layerView.layer.contentsGravity = kCAGravityCenter;

  //set the contentsScale to match image
  self.layerView.layer.contentsScale = image.scale;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.4.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.4 同样的Retina图片设置了正确的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;之后&lt;/p&gt;

&lt;p&gt;当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;layer.contentsScale = [UIScreen mainScreen].scale;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;masktobounds&quot;&gt;maskToBounds&lt;/h2&gt;

&lt;p&gt;现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：它超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。&lt;/p&gt;

&lt;p&gt;UIView有一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;clipsToBounds&lt;/code&gt;的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;masksToBounds&lt;/code&gt;，把它设置为YES，雪人就在边界里啦～（如图2.5）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.5.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.5 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;masksToBounds&lt;/code&gt;来修建图层内容&lt;/p&gt;

&lt;h2 id=&quot;contentsrect&quot;&gt;contentsRect&lt;/h2&gt;

&lt;p&gt;CALayer的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsGravity&lt;/code&gt;灵活多了&lt;/p&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;bounds&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;frame&lt;/code&gt;不同，&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;不是按点来计算的，它使用了&lt;em&gt;单位坐标&lt;/em&gt;，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以它们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。&lt;/li&gt;
  &lt;li&gt;像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，它们表现出来了不同的大小。&lt;/li&gt;
  &lt;li&gt;单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.6.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.6 一个自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;（左）和之前显示的内容（右）&lt;/p&gt;

&lt;p&gt;事实上给&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;在app中最有趣的地方在于一个叫做&lt;em&gt;image sprites&lt;/em&gt;（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。&lt;/p&gt;

&lt;p&gt;典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等&lt;/p&gt;

&lt;p&gt;2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.7.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;，然后设置每个图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;来去掉我们不想显示的部分。&lt;/p&gt;

&lt;p&gt;我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来访问它们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;
@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *coneView;
@property (nonatomic, weak) IBOutlet UIView *shipView;
@property (nonatomic, weak) IBOutlet UIView *iglooView;
@property (nonatomic, weak) IBOutlet UIView *anchorView;
@end

@implementation ViewController

- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image
{
  layer.contents = (__bridge id)image.CGImage;

  //scale contents to fit
  layer.contentsGravity = kCAGravityResizeAspect;

  //set contentsRect
  layer.contentsRect = rect;
}

- (void)viewDidLoad 
{
  [super viewDidLoad]; //load sprite sheet
  UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];
  //set igloo sprite
  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];
  //set cone sprite
  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];
  //set anchor sprite
  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];
  //set spaceship sprite
  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.8.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入得更快），但是如果有手动安排的话，它们还是有一些不方便的，如果你需要在一个已经创建好的拼合图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。&lt;/p&gt;

&lt;p&gt;Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsRect&lt;/code&gt;，这样开发者就不用手动写代码来摆放位置了。&lt;/p&gt;

&lt;p&gt;这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（&lt;a href=&quot;https://github.com/nicklockwood/LayerSprites&quot;&gt;https://github.com/nicklockwood/LayerSprites&lt;/a&gt;)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。&lt;/p&gt;

&lt;h2 id=&quot;contentscenter&quot;&gt;contentsCenter&lt;/h2&gt;

&lt;p&gt;本章我们介绍的最后一个和内容有关的属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;是{0, 0, 1, 1}，这意味着如果大小（由&lt;code class=&quot;highlighter-rouge&quot;&gt;conttensGravity&lt;/code&gt;决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;设置为{0.25, 0.25, 0.5, 0.5}的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.9.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.9 &lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;的例子&lt;/p&gt;

&lt;p&gt;这意味着我们可以随意重设尺寸，边框仍然会是连续的。它工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.10.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.10 同一图片使用不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11&lt;/p&gt;

&lt;p&gt;清单2.4 用&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;设置可拉伸视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *button1;
@property (nonatomic, weak) IBOutlet UIView *button2;

@end

@implementation ViewController

- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer
{  
  //set image
  layer.contents = (__bridge id)image.CGImage;

  //set contentsCenter
  layer.contentsCenter = rect;
}

- (void)viewDidLoad
{
  [super viewDidLoad]; //load button image
  UIImage *image = [UIImage imageNamed:@&quot;Button.png&quot;];

  //set button 1
  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];

  //set button 2
  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.11.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.11 用Interface Builder 探测窗口控制&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsCenter&lt;/code&gt;属性&lt;/p&gt;

&lt;h2 id=&quot;custome-drawing&quot;&gt;Custome Drawing&lt;/h2&gt;

&lt;p&gt;给&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt;方法来自定义绘制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt; 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt; 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 &lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;的值。&lt;/p&gt;

&lt;p&gt;如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。&lt;/p&gt;

&lt;p&gt;当视图在屏幕上出现的时候 &lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt;方法就会被自动调用。&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt;方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;-setNeedsDisplay&lt;/code&gt;方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如&lt;code class=&quot;highlighter-rouge&quot;&gt;bounds&lt;/code&gt;属性）。虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt;方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。&lt;/p&gt;

&lt;p&gt;CALayer有一个可选的&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;属性，实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayerDelegate&lt;/code&gt;协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;属性被声明为id类型，所有的代理方法都是可选的）。&lt;/p&gt;

&lt;p&gt;当需要被重绘时，CALayer会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;(void)displayLayer:(CALayer *)layer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;趁着这个机会，如果代理想直接设置&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现&lt;code class=&quot;highlighter-rouge&quot;&gt;-displayLayer:&lt;/code&gt;方法，CALayer就会转而尝试调用下面这个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由&lt;code class=&quot;highlighter-rouge&quot;&gt;bounds&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;contentsScale&lt;/code&gt;决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。&lt;/p&gt;

&lt;p&gt;让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是它的结果&lt;/p&gt;

&lt;p&gt;清单2.5 实现CALayerDelegate&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@implementation ViewController
- (void)viewDidLoad
{
  [super viewDidLoad];
  ￼
  //create sublayer
  CALayer *blueLayer = [CALayer layer];
  blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
  blueLayer.backgroundColor = [UIColor blueColor].CGColor;

  //set controller as layer delegate
  blueLayer.delegate = self;

  //ensure that layer backing image uses correct scale
  blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view
  [self.layerView.layer addSublayer:blueLayer];

  //force layer to redraw
  [blueLayer display];
}

- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx
{
  //draw a thick red circle
  CGContextSetLineWidth(ctx, 10.0f); 
  CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
  CGContextStrokeEllipseInRect(ctx, layer.bounds);
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/2.12.png&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2.12 实现CALayerDelegate来绘制图层&lt;/p&gt;

&lt;p&gt;注意一下一些有趣的事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们在blueLayer上显式地调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;-display&lt;/code&gt;。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。&lt;/li&gt;
  &lt;li&gt;尽管我们没有用&lt;code class=&quot;highlighter-rouge&quot;&gt;masksToBounds&lt;/code&gt;属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;-displayLayer:&lt;/code&gt;的实现，那所有的问题就都没了。&lt;/p&gt;

&lt;p&gt;当使用寄宿了视图的图层的时候，你也不必实现&lt;code class=&quot;highlighter-rouge&quot;&gt;-displayLayer:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawLayer:inContext:&lt;/code&gt;方法来绘制你的寄宿图。通常做法是实现UIView的&lt;code class=&quot;highlighter-rouge&quot;&gt;-drawRect:&lt;/code&gt;方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用&lt;code class=&quot;highlighter-rouge&quot;&gt;-display&lt;/code&gt;方法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。&lt;/p&gt;

&lt;p&gt;在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察它们是如何放置和改变相互的尺寸的。&lt;/p&gt;

</description>
        <pubDate>Thu, 23 Jun 2016 08:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/23/ios_core_animation2_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/23/ios_core_animation2_introduction/</guid>
        
        <category>ios</category>
        
        <category>core-animation</category>
        
        
      </item>
    
      <item>
        <title>IOS 动画讲解一</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;图层的树状结构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;巨妖有图层，洋葱也有图层，你有吗？我们都有图层 – 史莱克&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做&lt;em&gt;Layer Kit&lt;/em&gt;这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。&lt;/p&gt;

&lt;p&gt;Core Animation是一个&lt;em&gt;复合引擎&lt;/em&gt;，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的&lt;em&gt;图层&lt;/em&gt;，存储在一个叫做&lt;em&gt;图层树&lt;/em&gt;的体系之中。于是这个树形成了&lt;strong&gt;UIKit&lt;/strong&gt;以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。&lt;/p&gt;

&lt;p&gt;在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的&lt;em&gt;静态&lt;/em&gt;组合以及布局特性。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;图层和视图&lt;/h2&gt;
&lt;p&gt;如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对&lt;em&gt;视图&lt;/em&gt;的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/1.1.jpeg&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1.1 一种典型的iOS屏幕（左边）和形成视图的层级关系（右边）&lt;/p&gt;

&lt;p&gt;在iOS当中，所有的视图都从一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;UIVIew&lt;/code&gt;的基类派生而来，&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;可以处理触摸事件，可以支持基于&lt;em&gt;Core Graphics&lt;/em&gt;绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。&lt;/p&gt;

&lt;h3 id=&quot;calayer&quot;&gt;CALayer&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;类在概念上和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;最大的不同是&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;不处理用户的交互。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;并不清楚具体的&lt;em&gt;响应链&lt;/em&gt;（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”）&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;平行的层级关系&lt;/h3&gt;
&lt;p&gt;每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;UIview&lt;/code&gt;都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;实例的图层属性，也就是所谓的&lt;em&gt;backing layer&lt;/em&gt;，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作（见图1.2）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/1.2.jpeg&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1.2 图层的树状结构（左边）以及对应的视图层级（右边）&lt;/p&gt;

&lt;p&gt;实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。&lt;/p&gt;

&lt;p&gt;但是为什么iOS要基于&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;，但是Mac OS有AppKit和&lt;code class=&quot;highlighter-rouge&quot;&gt;NSView&lt;/code&gt;的原因。他们功能上很相似，但是在实现上有着显著的区别。&lt;/p&gt;

&lt;p&gt;绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。&lt;/p&gt;

&lt;p&gt;实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在&lt;em&gt;呈现树&lt;/em&gt;和&lt;em&gt;渲染树&lt;/em&gt;，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;图层的能力&lt;/h2&gt;
&lt;p&gt;如果说&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？&lt;/p&gt;

&lt;p&gt;某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;，因为苹果已经通过&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;的高级API间接地使得动画变得很简单。&lt;/p&gt;

&lt;p&gt;但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;上实现的接口功能，这时除了介入Core Animation底层之外别无选择。&lt;/p&gt;

&lt;p&gt;我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;没有暴露出来的CALayer的功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阴影，圆角，带颜色的边框&lt;/li&gt;
  &lt;li&gt;3D变换&lt;/li&gt;
  &lt;li&gt;非矩形范围&lt;/li&gt;
  &lt;li&gt;透明遮罩&lt;/li&gt;
  &lt;li&gt;多级非线性动画&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;是怎样被利用起来的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;使用图层&lt;/h2&gt;
&lt;p&gt;首先我们来创建一个简单的项目，来操纵一些&lt;code class=&quot;highlighter-rouge&quot;&gt;layer&lt;/code&gt;的属性。打开Xcode，使用&lt;em&gt;Single View Application&lt;/em&gt;模板创建一个工程。&lt;/p&gt;

&lt;p&gt;在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作&lt;code class=&quot;highlighter-rouge&quot;&gt;layerView&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/1.3.jpeg&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1.3 灰色背景上的一个白色&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。&lt;/p&gt;

&lt;p&gt;我们当然可以简单地在已经存在的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。&lt;/p&gt;

&lt;p&gt;于是我们来创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;，并且把它作为我们视图相关图层的子图层。尽管&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签（图1.4），然后在vc的.m文件中引入&amp;lt;QuartzCore/QuartzCore.h&amp;gt;库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/1.4.jpeg&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1.4 把QuartzCore库添加到项目&lt;/p&gt;

&lt;p&gt;之后就可以在代码中直接引用&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;的属性和方法。在清单1.1中，我们用创建了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;，设置了它的&lt;code class=&quot;highlighter-rouge&quot;&gt;backgroundColor&lt;/code&gt;属性，然后添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;layerView&lt;/code&gt;背后相关图层的子图层（这段代码的前提是通过IB创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;layerView&lt;/code&gt;并做好了连接），图1.5显示了结果。&lt;/p&gt;

&lt;p&gt;清单1.1 给视图添加一个蓝色子图层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;#import &quot;ViewController.h&quot;
#import &amp;lt;QuartzCore/QuartzCore.h&amp;gt;
@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
￼
@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //create sublayer
    CALayer *blueLayer = [CALayer layer];
    blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    //add it to our view
    [self.layerView.layer addSublayer:blueLayer];
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/1.5.jpeg&quot; alt=&quot;IMG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1.5 白色&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;内部嵌套的蓝色&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。&lt;/p&gt;

&lt;p&gt;在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;树状层级。但是在iOS平台，使用轻量级的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;类并没有显著的性能影响（当然在Mac OS 10.8之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSView&lt;/code&gt;的性能同样也得到很大程度的提高）。&lt;/p&gt;

&lt;p&gt;使用图层关联的视图而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;的好处在于，你能在使用所有&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;底层特性的同时，也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;的高级API（比如自动排版，布局和事件处理）。&lt;/p&gt;

&lt;p&gt;然而，当满足以下条件的时候，你可能更需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开发同时可以在Mac OS上运行的跨平台应用&lt;/li&gt;
  &lt;li&gt;使用多种&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;的子类（见第六章，“特殊的图层“），并且不想创建额外的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;去包封装它们所有&lt;/li&gt;
  &lt;li&gt;做一些对性能特别挑剔的工作，比如对&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这一章阐述了图层的树状结构，说明了如何在iOS中由&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;的层级关系形成的一种平行的&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;层级关系，在后面的实验中，我们创建了自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;，并把它添加到图层树中。&lt;/p&gt;

&lt;p&gt;在第二章，“图层关联的图片”，我们将要研究一下&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;关联的图片，以及Core Animation提供的操作显示的一些特性。&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/22/ios_core_animation1_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/22/ios_core_animation1_introduction/</guid>
        
        <category>ios</category>
        
        <category>core-animation</category>
        
        
      </item>
    
      <item>
        <title>IOS 开源库讲解篇二</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImage&lt;/code&gt;是iOS开发中十分流行的库，大多数的开发者在下载图片或者加载网络图片并且本地缓存的时候，都会用这个框架。这个框架相对来说，源代码还是比较少的。&lt;/p&gt;

&lt;p&gt;先介绍类的整体架构关系，先有一个宏观的认识。然后讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;sd_setImageWithURL&lt;/code&gt;的加载逻辑，因为这是SDWebImage最核心的，也是很多面试会问到的。接下来会介绍Image的解码，然后讲解缓存处理。最后再讲解API设计方式,以及其他我认为有用的。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;整体架构关系&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;定义通用宏和方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageCompat&lt;/code&gt;宏定义和C语言的一些工具方法&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageOperation&lt;/code&gt;，定义通用的Operation协议，主要就是一个方法，cancel。从而在cancel的时候，可以面向协议编程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;下载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageDownloader&lt;/code&gt; 实际的下载功能和配置提供者，使用了&lt;strong&gt;单例&lt;/strong&gt;的设计模式.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageDownloaderOperation&lt;/code&gt;，继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperation&lt;/code&gt;，是一个异步的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperation&lt;/code&gt;,封装了&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;进行实际的下载任务.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;缓存处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoPurgeCache,NSCache&lt;/code&gt;的子类，用于内存&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，会在收到内存警告的时候，自动清空.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDImageCache&lt;/code&gt;，实际处理内存&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;和磁盘&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;功能类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageManager&lt;/code&gt;,宏观的从整体上管理整个框架的类.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageDecoder&lt;/code&gt;，图片的解码类，后面会详细的讲解如何解码的.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImagePrefetcher&lt;/code&gt;，图片的预加载管理.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;类别&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;类别用来为UIView和UIImageView等”添加”属性来存储必要的信息，同时暴露出接口，进行实际的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tips&quot;&gt;Tips：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;用类别来提供接口往往是最方便的，因为用户只需要import这个文件，就可以像使用原生SDK那样去开发，不需要修改原有的什么代码&lt;/li&gt;
  &lt;li&gt;面向对象开发有一个原则是－单一功能原则，所以不管是在开发一个Lib或者开发App的时候，尽量保证各个模块之前功能单一，这样会降低耦合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sdsetimagewithurl&quot;&gt;sd_setImageWithURL的加载逻辑&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;1. 取消当前正在加载的图片&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[self sd_cancelCurrentImageLoad];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个方法的实际调用源代码如下，其中key是UIImageViewImageLoad.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tips：operationDictionary是通过Runtime为UIView”添加”的属性&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sd_cancelImageLoadOperationWithKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//用一个字典来存储当前的加载operation
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NSMutableDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operationDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operationDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operationDictionary&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;objectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//两种类型，帧类型的的gif是多个operation，静态图是一个operaiton
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isKindOfClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDWebImageOperation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conformsToProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SDWebImageOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//这里属于面向协议编程，不关心具体的类，只关心遵守某个协议
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDWebImageOperation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//删除对应的key
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operationDictionary&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObjectForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;placeholderplaceholder&quot;&gt;2. 如果有PlaceHolder，设置placeHolder&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
   if (!(options &amp;amp; SDWebImageDelayPlaceholder)) {
        dispatch_main_async_safe(^{
            self.image = placeholder;
        });
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里的dispatch_main_async_safe是一个宏定义，会检查调用是否在主线程上，如果在主线程就直接调用，后台线程会用gcd切换到主线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define dispatch_main_async_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_async(dispatch_get_main_queue(), block);\
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;sdimagecache&quot;&gt;3. 根据SDImageCache来查缓存，看看是否有图片&lt;/h4&gt;

&lt;p&gt;查看缓存的是这个方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) {//异步返回查询的结果}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这块感觉代码优点难懂，其实这是执行了一个方法queryDiskCacheForKey:key，返回一个NSOperation,之所以这样，是因为从磁盘或者内存查询的过程是异步的，后面可能需要cancel，所以这样做。&lt;/p&gt;

&lt;p&gt;我们再看看queryDiskCacheForKey:key这个方法是怎么实现的？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock {
    //输入检查，这里省略掉
    //先检查磁盘缓存
    UIImage *image = [self imageFromMemoryCacheForKey:key];
    if (image) {
        doneBlock(image, SDImageCacheTypeMemory);
        return nil;
    }
    //检查磁盘缓存
    NSOperation *operation = [NSOperation new];
    dispatch_async(self.ioQueue, ^{//切换到io队列上，进行磁盘操作
            //省略中间检查代码
            //回归到主线程行，进行doneBlock操作
            dispatch_async(dispatch_get_main_queue(), ^{
                doneBlock(diskImage, SDImageCacheTypeDisk);
            });
        }
    });
    return operation;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;4. 创建下载任务&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id &amp;lt;SDWebImageOperation&amp;gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
 //这里是下载完成后的回调，没什么要讲解的，简单来说就是image下载成功，就wself.image = image;[wself setNeedsLayout];,下载失败仍然显示placeHolder。然后调用completion block回调。
        }];
//记录下来当前的下载，方便后面取消
[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来，我们来看看实际的下载operation是什么样子的 
也就是这个方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m&quot;&gt;-(id)downloadImageWithURL:options:progress:completed:&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;block&quot;&gt;5－1,由于有各种各样的block回调，例如下载进度的回调，完成的回调，所以需要一个数据结构来存储这些回调&lt;/h4&gt;

&lt;p&gt;所以，这个方法中，首先调用以下方法来存储回调&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
//...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，用来存储回调的数据结构是一个NSMutableDictionary,其中key是图片的url，value是回调的数组 
举个例子，存储后应该是这样的，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@{
        @&quot;http://iamgeurl&quot;:[
                            @{
                                @&quot;progress&quot;:progressBlock1,
                                @&quot;completed&quot;:completedBlock1,
                            },
                            @{
                                @&quot;progress&quot;:progressBlock2,
                                @&quot;completed&quot;:completedBlock2,
                              },
                           ],
            //其他
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;** Tips：注意，对于同一个URL，在第二次调用addProgressCallback:progressBlock用的时候，并不会执行createCallback，也就是说，保证一个URL在多次下载的时候，只进行多次回调，而不会进行多次网络请求**&lt;/p&gt;

&lt;p&gt;如果是我，可能更愿意用一个对象来存储这些block回调，觉得这个数据结构有点复杂，很难维护&lt;/p&gt;

&lt;h4 id=&quot;urlsdsetimagesdwebimagedownloaderoperation&quot;&gt;5－2,对于同一个url，在第一次调用sd_setImage的时候进行，创建网络请求&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageDownloaderOperation&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;创建的方法是这个&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[wself.operationClass alloc] initWithRequest:request
                                      options:options
                                     progress:^(NSInteger receivedSize, NSInteger expectedSize){//Progress 回调}
                                     completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished){//Completion回调}
                                     cancelled:^{//Cancel 回调}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在看看Progress回调&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //Block中强引用sself（weakself）,保证在执行结束前不会被释放
 SDWebImageDownloader *sself = wself; 
 //如果weakself已经为nil，此时已经释放了，所以直接放回
 if (!sself) return;
 //用__block来修饰callbacksForURL，保证在能在block中修改这个变量
 __block NSArray *callbacksForURL;
 //在队列`barrierQueue`里同步捕获callBack
 dispatch_sync(sself.barrierQueue, ^{
     callbacksForURL = [sself.URLCallbacks[url] copy];
 });
 for (NSDictionary *callbacks in callbacksForURL) {
//异步切换到主线程上进行回调
   dispatch_async(dispatch_get_main_queue(), ^{
         SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
         if (callback) callback(receivedSize, expectedSize);
     });
 }                             
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;completion回调和progress类似，不再赘述。 
再看看cancel block的处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SDWebImageDownloader *sself = wself;
if (!sself) return;
//阻碍barrierQueue,
dispatch_barrier_async(sself.barrierQueue, ^{
    [sself.URLCallbacks removeObjectForKey:url];
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Tips:这里为什么要用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;呢？因为&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;_barrierQueue是个并行队列，意味着队列上的任务可以并行执行。用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;来保证后续提交的block等待当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_asyncblock&lt;/code&gt;执行完毕后再执行。&lt;/p&gt;

&lt;p&gt;Tips：&lt;/p&gt;

&lt;p&gt;用这么多GCD是为了保证线程安全
再简单提一下&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;的用法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Calls to this function always return immediately after the block has been submitted and never wait for the block to be invoked. When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;imageview&quot;&gt;4. 下载图片完成后，根据需要图片解码和处理图片格式，回调给Imageview&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; UIImage *image = [UIImage sd_imageWithData:self.imageData];
            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
            image = [self scaledImageForKey:key image:image];

            // Do not force decoding animated GIFs
            if (!image.images) {
                if (self.shouldDecompressImages) {
                    image = [UIImage decodedImageWithImage:image];
                }
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结下整个调用过程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取消上一次调用&lt;/li&gt;
  &lt;li&gt;设置placeHolder&lt;/li&gt;
  &lt;li&gt;保存回调block&lt;/li&gt;
  &lt;li&gt;cache查询是否已经下载过了，先检查内存，后检查磁盘&lt;/li&gt;
  &lt;li&gt;利用NSURLConnection来下载图片，根据需要解码，回调给imageview，存储到缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;线程管理&lt;/h3&gt;

&lt;p&gt;整个SDWebImage一共有四个队列&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Main queue,主队列，在这个队列上进行UIKit对象的更新，发送notification&lt;/li&gt;
  &lt;li&gt;barrierQueue，并行队列，在这个队列上统一处理3-1中的数据回调，为了保证线程安全，一致使用dispatch_barrier_sync&lt;/li&gt;
  &lt;li&gt;ioQueue，用在图片的磁盘操作&lt;/li&gt;
  &lt;li&gt;downloadQueue（NSOperationQueue），用来全局的管理下载的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;图片解码&lt;/h3&gt;

&lt;p&gt;传统的UIImage进行解码都是在主线程上进行的，比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIImage * image = [UIImage imageNamed:@&quot;123.jpg&quot;]
self.imageView.image = image;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在这个时候，图片其实并没有解码。而是，当图片实际需要显示到屏幕上的时候，CPU才会进行解码，绘制成纹理什么的，交给GPU渲染。这其实是很占用主线程CPU时间的，而众所周知，主线程的时间真的很宝贵&lt;/p&gt;

&lt;p&gt;现在，我们看看SDWebImage是如何在后台进行解码的 
代码来自于这个原文件&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDecoder.m&quot;&gt;SDWebImageDecoder&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)decodedImageWithImage:(UIImage *)image {
    if (image == nil) { 
        return nil;
    }

    @autoreleasepool{
        //Gif不用解码，直接返回
        if (image.images != nil) {
            return image;
        }
        CGImageRef imageRef = image.CGImage
        ;
        CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef);
        BOOL anyAlpha = (alpha == kCGImageAlphaFirst ||
                         alpha == kCGImageAlphaLast ||
                         alpha == kCGImageAlphaPremultipliedFirst ||
                         alpha == kCGImageAlphaPremultipliedLast);
        if (anyAlpha) {
        //有Alpha通道，直接返回
            return image;
        }
        //获得Color Space
        CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));
        CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);

        BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown ||
                                      imageColorSpaceModel == kCGColorSpaceModelMonochrome ||
                                      imageColorSpaceModel == kCGColorSpaceModelCMYK ||
                                      imageColorSpaceModel == kCGColorSpaceModelIndexed);
        if (unsupportedColorSpace) {
            colorspaceRef = CGColorSpaceCreateDeviceRGB();
        }

        size_t width = CGImageGetWidth(imageRef);
        size_t height = CGImageGetHeight(imageRef);
        NSUInteger bytesPerPixel = 4;
        NSUInteger bytesPerRow = bytesPerPixel * width;
        NSUInteger bitsPerComponent = 8;
        //创建bitmapContext
        CGContextRef context = CGBitmapContextCreate(NULL,
                                                     width,
                                                     height,
                                                     bitsPerComponent,
                                                     bytesPerRow,
                                                     colorspaceRef,
                                                     kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);

        // 绘制Image到Context中，强制解码
        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);
        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);
        UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha
                                                         scale:image.scale
                                                   orientation:image.imageOrientation];

        if (unsupportedColorSpace) {
            CGColorSpaceRelease(colorspaceRef);
        }

        CGContextRelease(context);
        CGImageRelease(imageRefWithoutAlpha);

        return imageWithoutAlpha;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;缓存处理&lt;/h3&gt;

&lt;p&gt;整个缓存处理的类都在&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDImageCache.m&quot;&gt;SDImageCache&lt;/a&gt;文件中，其中缓存又包括两个方面，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存缓存&lt;/li&gt;
  &lt;li&gt;磁盘缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，内存缓存采用了NSCache的子类&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoPurgeCache&lt;/code&gt;，&lt;/p&gt;

&lt;p&gt;AutoPurgeCache 
只是对NSCache添加了在收到内存警告通知&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationDidReceiveMemoryWarningNotification&lt;/code&gt;的时候自动&lt;code class=&quot;highlighter-rouge&quot;&gt;removeAllObjects&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再看看磁盘缓存是如何做的？ 
磁盘缓存是基于文件系统的,也就是说图片是以普通文件的方式存储到沙盒里的。&lt;/p&gt;

&lt;p&gt;缓存的目录是啥？ 
默认的缓存目录是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lbirary/Caches/default/com.hackemist.SDWebImageCache.default/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缓存的文件名称是对缓存的key求md5&lt;/p&gt;

&lt;p&gt;何时自动清除过期图片？ 
在App关闭的时候&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(cleanDisk)
                                             name:UIApplicationWillTerminateNotification
                                           object:nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;清除的逻辑很简单，获取文件的modify时间，然后比较下过期时间，如果过期了就删除。当磁盘缓存超过阈值后，根据最后访问的时间排序，删除最老的访问图片。&lt;/p&gt;

&lt;p&gt;存储成什么格式？&lt;/p&gt;

&lt;p&gt;见SDImageCache中，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取Alpha信息
int alphaInfo = CGImageGetAlphaInfo(image.CGImage);
BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||
                  alphaInfo == kCGImageAlphaNoneSkipFirst ||
                  alphaInfo == kCGImageAlphaNoneSkipLast);
BOOL imageIsPng = hasAlpha;

//如果又imageData，并且有png的前8个字节，根据NSData前8个字节来检查是否是png
if ([imageData length] &amp;gt;= [kPNGSignatureData length]) {
    imageIsPng = ImageDataHasPNGPreffix(imageData);
}
//如果是Png，存储成png
if (imageIsPng) {
    data = UIImagePNGRepresentation(image);
}
else {
//否则存储称jpg
    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;deprecatedapi&quot;&gt;deprecated一个API&lt;/h3&gt;

&lt;p&gt;只需要在方法后面，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;__deprecated_msg&lt;/code&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSString *)contentTypeForImageData:(NSData *)data __deprecated_msg(&quot;Use `sd_contentTypeForImageData:`&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-12&quot;&gt;条件编译&lt;/h3&gt;

&lt;p&gt;这个在之前AsyncDisplayKit解析的文章里也提到过，这里再提一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if TARGET_OS_IPHONE &amp;amp;&amp;amp; __IPHONE_OS_VERSION_MAX_ALLOWED &amp;gt;= __IPHONE_4_0
//代码
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;又比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if TARGET_OS_IOS 
//代码for iOS
#else
//代码for osx
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就是条件编译，根据条件是否满足来让编译器编译这段代码。&lt;/p&gt;

&lt;p&gt;**Tips：根据条件编译，可以为不同的版本的iOS做一些适配 **&lt;/p&gt;

&lt;h3 id=&quot;gif&quot;&gt;如何实现Gif动图？&lt;/h3&gt;

&lt;p&gt;本质上，使用这个iOS SDK提供的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//传入一个Image数组，和动画的时间
animatedImage = [UIImage animatedImageWithImages:images duration:duration];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，如何解析Gif图片呢？ 
原理也比较简单，源代码在&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/SDWebImage/UIImage+GIF.m&quot;&gt;UIImage+GIF&lt;/a&gt;.m中。利用&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CGImageSource/&quot;&gt;CGImageSource&lt;/a&gt;的一系列方法依次提取每一帧的图片和每一帧的图片间隔，然后用上文提到的API来实现Gif&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tips：在ARC开启的时候，Foundation对象（CF开头）和CoreGraphics对象(CG开头）的一些对象仍然需要手动管理，例如&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);
//利用完毕
    CGImageRelease(image);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-13&quot;&gt;获取图片的格式&lt;/h3&gt;

&lt;p&gt;原文件&lt;code class=&quot;highlighter-rouge&quot;&gt;NSData+ImageContentType.m&lt;/code&gt; ,代码不难，不做讲解了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSString *)sd_contentTypeForImageData:(NSData *)data {
    uint8_t c;
    [data getBytes:&amp;amp;c length:1];
    switch (c) {
        case 0xFF:
            return @&quot;image/jpeg&quot;;
        case 0x89:
            return @&quot;image/png&quot;;
        case 0x47:
            return @&quot;image/gif&quot;;
        case 0x49:
        case 0x4D:
            return @&quot;image/tiff&quot;;
        case 0x52:
            // R as RIFF for WEBP
            if ([data length] &amp;lt; 12) {
                return nil;
            }

            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];
            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;amp;&amp;amp; [testString hasSuffix:@&quot;WEBP&quot;]) {
                return @&quot;image/webp&quot;;
            }

            return nil;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-14&quot;&gt;预下载&lt;/h3&gt;

&lt;p&gt;原文件&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImagePrefetcher.m&quot;&gt;SDWebImagePrefetcher.m&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以看到，由于类的功能划分非常清楚，所以SDWebImagePrefetcher 的实现文件很简单，本质上只是用单例的设计模式，并且这个类保存了&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImageManager&lt;/code&gt;对象来进行的实际下载操作&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;设计方式的一点理解&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;整个框架的处理核心是SDWebImageManager类，而为了让使用者在使用的时候不必实例化这个类的一个对象，整个类采用了单利的设计模式。&lt;/li&gt;
  &lt;li&gt;用block的方式，处理复杂的异步回调。用block的方式，在这里是要比代理来的简单直接的。如果用代理，那么上文讲解的sd_setImageWithURL的过程，将会有复杂的代理回调方法&lt;/li&gt;
  &lt;li&gt;每个线程处理自己的独立任务。上文提到了，这个库一共有四个Queue&lt;/li&gt;
  &lt;li&gt;面向协议编程。这个在SDWebImageOperation协议的体现上十分明显。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SDWebImageOperation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在使用的时候，只需关注协议的本身就可以了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conformsToProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SDWebImageOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]){&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SDWebImageOperation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operations&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用Category的方式提供接口,例如UIImageView+WebCache等，这样能最大程度的降低使用者的使用难度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单一功能原则,这个在上文提到了，每个类or文件负责单一的功能，方便独立测试和维护&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最好的例子就是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIImage+GIF.h
UIImage+MultiFormat
UIImageView+HighlightedWebCache.h
UIImageView+WebCache.h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;线程安全的保证。很明显，SDWebImage不能强求用户在某一个线程上调用，然后自己切换回主线程。所以你会看到类似这样的代码来保证线程安全&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@synchronized (self) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_barrier_sync(sself.barrierQueue, ^{
                                                                callbacksForURL = [sself.URLCallbacks[url] copy];
                                                                if (finished) {
                                                                    [sself.URLCallbacks removeObjectForKey:url];
                                                                }
                                                            });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-16&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;SDWebImage相对来说，源代码没有那么多，建议大家好好研究下源代码。对图片的基础知识巩固，各种线程的处理方式，类的架构和API设计等都很有帮助。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/21/ios_sdwebimage_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/21/ios_sdwebimage_introduction/</guid>
        
        <category>ios</category>
        
        <category>Xcode</category>
        
        <category>SDWebImage</category>
        
        
      </item>
    
      <item>
        <title>IOS 开源库讲解篇一</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;iOS开发中，不管是哪种设计模式，Model层都是不可或缺的。而Model层的第三方库常用的库有以下几个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JSONModel&lt;/li&gt;
  &lt;li&gt;Mantle&lt;/li&gt;
  &lt;li&gt;MJExtension&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JSON data到对象的转换原理都差不多，一般的顺序如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据Runtime，动态的获取属性的类型和属性的名字，（如果需要，做一次Json的key的Mapping&lt;/li&gt;
  &lt;li&gt;创建对应的对象实例&lt;/li&gt;
  &lt;li&gt;根据KVC（NSKeyValueCoding协议）来为属性设置值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mantle就是这样的一个库，个人比较喜欢Mantle,而且在Github的Star也是提到的几个库中最多的。Mantle除了提供JSON和对象的相互转化，继承自MTLModel的对象还自动实现了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCopying&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCoding&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isEqual&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;正文开始啦&lt;/h3&gt;

&lt;p&gt;如果要理解JSON到Model转化的原理，需要理解&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;下面说下&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;的几个基础知识,以及Mantle本身&lt;/p&gt;

&lt;h4 id=&quot;runtime&quot;&gt;Runtime动态获取类的属性&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-object-c&quot;&gt;@interface Base : NSObject

@property (copy,nonatomic) NSString * basemodel;

@end

@interface Demo : Base

@property (nonatomic,copy) NSString * name;
@property (nonatomic,strong) NSDate * createAt;
@property (nonatomic,assign) CGFloat num;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后, 写一个方法来Log Model&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)logAllModel{
    uint count;
    objc_property_t * models = class_copyPropertyList(Demo.class,&amp;amp;count);
    @try {
        for (int i = 0; i &amp;lt; count ; i++) {
            objc_property_t  model = propertys[i];
            NSLog(@&quot;%@&quot;,@(property_getName(model)));
        }
    }@finally {
        free(models);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;打印出来是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2016-06-20 22:05:25.773 TestModel[3276:203701] name
2016-06-20 22:05:25.773 TestModel[3276:203701] createAt
2016-06-20 22:05:25.773 TestModel[3276:203701] num
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不难发现&lt;code class=&quot;highlighter-rouge&quot;&gt;class_copyPropertyList&lt;/code&gt;仅仅是获取了当前类的属性列表，并没有获取基类的属性对象。所以对上述方法进行修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)logAllModel{
    Class cls = Demo.class;
    while (![cls isEqual:NSObject.class]) {
        uint count;
        objc_property_t * models;
        @try {
            models = class_copyPropertyList(cls,&amp;amp;count);
            cls = cls.superclass;
            for (int i = 0; i &amp;lt; count ; i++) {
                objc_property_t  model = models[i];
                NSLog(@&quot;%@&quot;,@(property_getName(model)));
            }
        }@finally {
            free(models);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_copyPropertyList&lt;/code&gt;返回一个数组，这个数字必须要手动释放，所以用&lt;code class=&quot;highlighter-rouge&quot;&gt;Try-Catch-Finally&lt;/code&gt;包裹起来。&lt;/p&gt;

&lt;h4 id=&quot;runtimeattributes&quot;&gt;Runtime来获取属性的attributes&lt;/h4&gt;

&lt;p&gt;关键方法property_getAttributes，返回个一个C类型的字符串。&lt;/p&gt;

&lt;p&gt;我们先声明一个这样的属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，打印出它的attributes信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(@&quot;%@&quot;,@(property_getAttributes(class_getProperty(self.class,@&quot;name&quot;.UTF8String))));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到Log是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2016-06-20 22:07:25.723 TestModel[3276:203701] T@,R,C,N,V_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的Attributes字符串是编码后的字符串，分为三个部分&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T@,T&lt;/code&gt;表示开头，后面跟着属性的类型，&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;类型.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vname，V&lt;/code&gt;表示中间部分的结束，后面跟&lt;code class=&quot;highlighter-rouge&quot;&gt;ivar&lt;/code&gt;名字,自动合成呢的情况下前面加下划线.&lt;/li&gt;
  &lt;li&gt;中间R,C,N用逗号隔开，表示属性的描述，&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Nonatomic&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mantle&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactiveCocoa&lt;/code&gt;都是采用了&lt;a href=&quot;https://github.com/Mantle/Mantle/tree/master/Mantle/extobjc&quot;&gt;extobjc&lt;/a&gt;这个OC的Runtime工具类将属性的详细信息提取到一个结构体里的，原理都是一样的。提取完成的结构体是&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/extobjc/EXTRuntimeExtensions.h&quot;&gt;mtl_propertyAttributes&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;matnle&quot;&gt;Matnle的类的组织架构&lt;/h4&gt;

&lt;p&gt;按照文件的方式，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLJSONAdapter.h&quot;&gt;MTLJSONAdapter.h&lt;/a&gt;,定义了协议&lt;code class=&quot;highlighter-rouge&quot;&gt;MTLJSONSerializing&lt;/code&gt;和适配器类&lt;code class=&quot;highlighter-rouge&quot;&gt;MTLJSONAdapter&lt;/code&gt;,这两个协议/类定义了接口来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-MTLModel&lt;/code&gt;的转换。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLModel.h&quot;&gt;MTLModel.h&lt;/a&gt;，定义了协议MTLModel和基类MTLModel，基类MTLModel实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;isEqual,NSCopying&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;几个方法。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLModel%2BNSCoding.h&quot;&gt;MTLModel+NSCoding.h&lt;/a&gt;,MTLModel的类别，让其支持NSCoding协议&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLValueTransformer.h&quot;&gt;MTLValueTransformer.h&lt;/a&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSValueTransformer&lt;/code&gt;的子类，定义了将一个value转变成另一个value的接口。例如，返回的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;2020-01-01T15:33:30&lt;/code&gt;字符串，利用转换block转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDate&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;其它的都是工具类，提供工具方法，不全列出来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;json-&quot;&gt;JSON-&amp;gt;对象的处理过程&lt;/h4&gt;

&lt;p&gt;以下面代码调用为例（为了看起来不那么臃肿，省略不必要的代码）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Demo * demo = [MTLJSONAdapter modelOfClass:[Demo class] fromJSONDictionary:json error:&amp;amp;error];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看看这个方法的具体实现，就知道分为两个大的过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error {
    //1.根据modelClass初始化一个adapter
    MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];
    //2.adapter解析实际的JSON数据
    return [adapter modelFromJSONDictionary:JSONDictionary error:error];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在看看整个第一大步，&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLJSONAdapter.m&quot;&gt;initWithModelClass&lt;/a&gt;，Mantle做了什么，&lt;/p&gt;

&lt;h5 id=&quot;modelclass&quot;&gt;1.1，断言检查，并保存modelClass&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;NSParameterAssert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NSParameterAssert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conformsToProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MTLJSONSerializing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_modelClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;mtljsonserialingjsonkeypathsbypropertykey-json-key&quot;&gt;1.2,获取所有的属性名字，获取MTLJSONSerialing中JSONKeyPathsByPropertyKey方法提供的属性名字-&amp;gt;JSON key的映射，并进行合法性检查&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //属性名－&amp;gt;JSON key的映射
    JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];
    //所有的属性集合
    NSSet *propertyKeys = [self.modelClass propertyKeys];
    //每一个属性进行检查
    for (NSString *mappedPropertyKey in _JSONKeyPathsByPropertyKey) {
        //检查属性名－&amp;gt;JSON Key映射的属性名是否合法
        if (![propertyKeys containsObject:mappedPropertyKey]) {
            NSAssert(NO, @&quot;%@ is not a property of %@.&quot;, mappedPropertyKey, modelClass);
            return nil;
        }
        //获取对应的JSON key
        id value = _JSONKeyPathsByPropertyKey[mappedPropertyKey];
        //如果是Array（支持JSON key是Array）
        if ([value isKindOfClass:NSArray.class]) {
            //Array中的每一个Key必须是String类型
            for (NSString *keyPath in value) {
                if ([keyPath isKindOfClass:NSString.class]) continue;

                NSAssert(NO, @&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;, mappedPropertyKey, value);
                return nil;
            }
        } else if (![value isKindOfClass:NSString.class]) {
            //检查JSON key是否时Array类型
            NSAssert(NO, @&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;,mappedPropertyKey, value);
            return nil;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;nsvaluetransformerjson2015-10-01t131515nsdate&quot;&gt;1.3 获取所有的NSValueTransformer,来方便做值转换（例如：服务器JSON返回的是2015-10-01T13:15:15,转换成NSDate）&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_valueTransformersByPropertyKey = [self.class valueTransformersForModelClass:modelClass];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用过Mantle的都知道，mantle利用”属性名+JSONTransformer”的方法名字来提供NSValueTransformer, 
这里Mantle用了一些Runtime稍微高级点的东西，所以这个方法我会详细讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;valueTransformersForModelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;propertyKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//对每一个key检查NSValueTransformer
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//根据属性名字＋JSONTransformer来合成一个Selector
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MTLSelectorWithKeyPattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;JSONTransformer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;respondsToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//如果提供了Transformer方法
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//获取IMP指针，也就是实际方法的执行体
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;IMP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;methodForSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//OC方法转换为C方法的时候，前两个参数是_cmd,和SEL，所以，这里做一个强制转化，方便下一行执行
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;NSValueTransformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__typeof__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//获取transformer，保存到Dictionary
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;NSValueTransformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//检查是否通过协议方法JSONTransformerForKey来提供NSValueTransformer
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;respondsToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;JSONTransformerForKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:)])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//把一个属性的类型，关键字，属性名字提取到一个结构体中
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;objc_property_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class_getProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UTF8String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mtl_propertyAttributes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mtl_copyPropertyAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;@onExit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSValueTransformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//如果某一个属性是id类型
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//获得该属性的实际类名
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objectClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//获取该类名型提供的NSValueTransformer,即类是否提供了keyJSONTransformer方法
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transformerForModelPropertiesOfClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//如果该类型也是一个MTLModel，并且实现了MTLJSONSerializing，获取该对象的NSValueTransformer,也就是保证了在MTLModel的一个属性也是一个MTLModel的时候能够正常工作
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conformsToProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MTLJSONSerializing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dictionaryTransformerWithModelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//如果仍然没有获取到transformer，验证对于modalClass是否可转换
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSValueTransformer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mtl_validatingTransformerForClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;propertyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//不是ID类型，则是值类型的transformer
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transformerForModelPropertiesOfObjCType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSValueTransformer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mtl_validatingTransformerForClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再看看第二大步，Adapter如何解析JSON 
即这个方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error {
//...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;jsonjson&quot;&gt;2.1，检查是否实现了聚类方式解析JSON，例如解析这样的JSON&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
    {
        &quot;key1&quot;:&quot;value1&quot;,
        &quot;key2&quot;:&quot;value2&quot;
    },
    {
        &quot;key3&quot;:&quot;value3&quot;,
        &quot;key4&quot;:&quot;value4&quot;

    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对应代码块&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if ([self.modelClass respondsToSelector:@selector(classForParsingJSONDictionary:)]) {
        //...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;propertypropertykeyjson-keyjson-key-mtlvalueforjsonkeypathsuccesserrorhttpsgithubcommantlemantleblobmastermantlensdictionary2bmtljsonkeypathm&quot;&gt;2.2，对于每一个Property的名字，即propertyKey，获取对应的JSON key。根据JSON key 来获取对应的值，主要掉用&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/NSDictionary%2BMTLJSONKeyPath.m&quot;&gt;mtl_valueForJSONKeyPath:success:error:&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;这个方法很简单，比如对应json的keyPath是person.name.first 
先分解成person,name,first,然后一层一层的获取json[person][name][first],只不过Mantle在解析的时候，用了个for循环，来给用户反馈，到底错误在哪里。个人感觉用以下两个KVC的方法更简洁一点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//验证是否可用KVC
- validateValue:forKeyPath:error:
//用KVC来获取值
- valueForKeyPath:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;nsvaluetransformernsvaluetransformer&quot;&gt;2.3，对于2.2种，获取到的值，利用1.3的NSValueTransformer进行转换，这里只知道NSValueTransformer能够把一个值转换成另一个值就行了，后面会详细讲解如何转换的。&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Tips: 
这里要提到的是，Mantle采用了条件编译方式来处理异常，即debug模式下会抛出异常给开发者，但是release模式下，不会崩溃&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if DEBUG
    @throw ex;
#else
    //...           
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;keykvckvc&quot;&gt;2.4 根据以上三步得到的值字典，对每一个key利用KVC进行设置值，KVC设置值之前，调用&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[obj validateValue:&amp;amp;validatedValue forKey:key error:error]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;来验证是否可以KVC&lt;/p&gt;

&lt;h4 id=&quot;nsvaluetransformer&quot;&gt;NSValueTransformer&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSValueTransformer_Class/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSValueTranformer是一个抽象的基类，利用Cocoa Bindings技术来进行值的相互转换
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;既然是一个抽象基类，那么使用的时候要继承这个基类，然后实现必要的方法，从而才能进行相应的值转换。&lt;/p&gt;

&lt;p&gt;例如,实现一个简单的NSDate&amp;lt;-&amp;gt;NSString转换的Transformer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LHValueTransformer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSValueTransformer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LHValueTransformer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allowsReverseTransformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformedValueClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDateFormatter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateFormatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSDateFormatter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;formatter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDateFormatter&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;formatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateFormat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;formatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSAssert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isKindOfClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSDate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Should a NSDate value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dateFormatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stringFromDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverseTransformedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSAssert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isKindOfClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Should be a NSString value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dateFormatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dateFromString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，这样掉用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSValueTransformer * trans = [[LHValueTransformer alloc] init];

    NSDate * date = [NSDate date];
    NSString * str = [trans transformedValue:date];
    NSDate * date2 = [trans reverseTransformedValue:str];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MTLValueTransformer就是这样的一个子类，只不过它提供了正反两个转换的block作为接口。&lt;/p&gt;

&lt;h4 id=&quot;isequalnscopyinghash&quot;&gt;isEqual，NSCopying，hash&lt;/h4&gt;

&lt;p&gt;实现NSCopying和hash很简单，就是基类根据Runtime动态的获取所有的属性，然后对应的进行操作就可以了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma mark NSCopying

- (instancetype)copyWithZone:(NSZone *)zone {
    MTLModel *copy = [[self.class allocWithZone:zone] init];
    [copy setValuesForKeysWithDictionary:self.dictionaryValue];
    return copy;
}

#pragma mark NSObject

- (NSString *)description {
    NSDictionary *permanentProperties = [self dictionaryWithValuesForKeys:self.class.permanentPropertyKeys.allObjects];

    return [NSString stringWithFormat:@&quot;&amp;lt;%@: %p&amp;gt; %@&quot;, self.class, self, permanentProperties];
}

- (NSUInteger)hash {
    NSUInteger value = 0;
    //每个value取hash值
    for (NSString *key in self.class.permanentPropertyKeys) {
        value ^= [[self valueForKey:key] hash];
    }

    return value;
}

- (BOOL)isEqual:(MTLModel *)model {
    if (self == model) return YES;
    if (![model isMemberOfClass:self.class]) return NO;

    for (NSString *key in self.class.permanentPropertyKeys) {
        id selfValue = [self valueForKey:key];
        id modelValue = [model valueForKey:key];
        //每一个value取isEqual
        BOOL valuesEqual = ((selfValue == nil &amp;amp;&amp;amp; modelValue == nil) || [selfValue isEqual:modelValue]);
        if (!valuesEqual) return NO;
    }

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nscoding&quot;&gt;NSCoding&lt;/h4&gt;

&lt;p&gt;NSCoding的支持有些复杂，源代码&lt;a href=&quot;https://github.com/Mantle/Mantle/blob/master/Mantle/MTLModel%2BNSCoding.m&quot;&gt;MTLModel+NSCoding.m&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithCoder:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据Runtime，获取所有的属性名字.&lt;/li&gt;
  &lt;li&gt;对于每一个属性，检查是否响应&lt;code class=&quot;highlighter-rouge&quot;&gt;decodeWithCoder:modelVersion:&lt;/code&gt;,也就是说，支持属性也是MTLModel对象，如果是，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;decodeWithCoder:modelVersion:&lt;/code&gt;解析这个MTLModel&lt;/li&gt;
  &lt;li&gt;如果不是MTLModel子类，则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;decodeObjectForKey&lt;/code&gt;来解析，这里的key就是属性的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;encodeWithCoder类似，不做讲解&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;异常处理&lt;/h4&gt;

&lt;p&gt;Mantle中，有一些&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@try{}
@catch{}
@finally{}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且在catch模块中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if DEBUG
    @throw ex;
#else
    //其它处理
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样能够方便调试错误，并且在运行时的时候不崩溃。&lt;/p&gt;

&lt;p&gt;同时，你还能看到这样的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mtl_propertyAttributes *attributes = mtl_copyPropertyAttributes(property);
@onExit {
    free(attributes);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;@onExit&lt;/code&gt;是一个宏定义，保证代码在在当前域返回（return，break，异常）始终能执行到。其实本质就是把代码放到了finally里&lt;/p&gt;

&lt;h4 id=&quot;attribute&quot;&gt;&lt;strong&gt;attribute&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;__attribute__机制能够为方法，变量，类型增加额外的属性。&lt;/p&gt;

&lt;p&gt;**增加的额外属性，能够让编译器进行额外的检查，从而提供额外的提示 **&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MTLJSONSerializing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unavailable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Replaced by -modelFromJSONDictionary:error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;JSONArrayFromModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;models&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deprecated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Replaced by +JSONArrayFromModels:error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NS_SWIFT_UNAVAILABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Replaced by +JSONArrayFromModels:error:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就分别提示model当前不可用unavailable，和&lt;code class=&quot;highlighter-rouge&quot;&gt;JSONArrayFromModels&lt;/code&gt;方法被&lt;code class=&quot;highlighter-rouge&quot;&gt;deprecated&lt;/code&gt;。&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/20/ios_mantle_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/20/ios_mantle_introduction/</guid>
        
        <category>ios</category>
        
        <category>Xcode</category>
        
        <category>Mantle</category>
        
        
      </item>
    
      <item>
        <title>Android 快速开发库</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;1. 缓存&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/JakeWharton/DiskLruCache&quot;&gt;DiskLruCache&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java实现基于LRU的磁盘缓存&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.图片加载&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/nostra13/Android-Universal-Image-Loader&quot;&gt;Android Universal Image Loader&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个强大的加载，缓存，展示图片的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/picasso&quot;&gt;Picasso&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个强大的图片下载与缓存的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/fresco&quot;&gt;Fresco&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个用于管理图像和他们使用的内存的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/bumptech/glide&quot;&gt;Glide&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个图片加载和缓存的库&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 图片处理&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/wasabeef/picasso-transformations&quot;&gt;Picasso-transformations&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个为Picasso提供多种图片变换的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/wasabeef/glide-transformations&quot;&gt;Glide-transformations&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个为Glide提供多种图片变换的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/CyberAgent/android-gpuimage&quot;&gt;Android-gpuimage&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;基于OpenGL的Android过滤器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 网络请求&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/loopj/android-async-http&quot;&gt;Android Async HTTP&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android异步HTTP库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/koush/AndroidAsync&quot;&gt;AndroidAsync&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/okhttp&quot;&gt;OkHttp&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个Http与Http/2的客户端&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;Retrofit&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;类型安全的Http客户端&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/volley&quot;&gt;Volley&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Google推出的Android异步网络请求框架和图片加载框架&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5. 网络解析&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/google/gson&quot;&gt;Gson	&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个Java序列化/反序列化库，可以将JSON和java对象互相转换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/codehaus/jackson&quot;&gt;Jackson&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/alibaba/fastjson&quot;&gt;Fastjson&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java上一个快速的JSON解析器/生成器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://sourceforge.net/projects/htmlparser/&quot;&gt;HtmlPaser&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一种用来解析单个独立html或嵌套html的方式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;Jsoup&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个以最好的DOM，CSS和jQuery解析html的库&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-5&quot;&gt;6. 数据库&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://sourceforge.net/projects/ormlite/files/releases/com/j256/ormlite/&quot;&gt;OrmLite&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;JDBC和Android的轻量级ORM java包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/satyan/sugar&quot;&gt;Sugar&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;用超级简单的方法处理Android数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/greenrobot/greenDAO&quot;&gt;GreenDAO&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一种轻快地将对象映射到SQLite数据库的ORM解决方案&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/pardom/ActiveAndroid&quot;&gt;ActiveAndroid&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;以活动记录方式为Android SQLite提供持久化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/sqlbrite&quot;&gt;SQLBrite&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SQLiteOpenHelper 和ContentResolver的轻量级包装&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;Realm&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;移动数据库：一个SQLite和ORM的替换品&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-6&quot;&gt;7. 依赖注入&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot;&gt;ButterKnife&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;将Android视图和回调方法绑定到字段和方法上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/google/dagger&quot;&gt;Dagger2&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个Android和java快速依赖注射器。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/excilys/androidannotations&quot;&gt;AndroidAnotations&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;快速安卓开发。易于维护&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/roboguice/roboguice&quot;&gt;RoboGuice&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android平台的Google Guice&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-7&quot;&gt;8. 图表&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/diogobernardino/WilliamChart&quot;&gt;WilliamChart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;创建图表的Android库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/lecho/hellocharts-android&quot;&gt;HelloCharts&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;兼容到API8的Android图表库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/PhilJay/MPAndroidChart&quot;&gt;MPAndroidChart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个强大的Android图表视图/图形库&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-8&quot;&gt;9. 后台处理&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/tape&quot;&gt;Tape&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个轻快的，事务性的，基于文件的FIFO的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/yigit/android-priority-jobqueue&quot;&gt;Android Priority Job Queue&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个专门为Android轻松调度任务的工作队列&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-9&quot;&gt;10. 事件总线&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;EventBus&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;安卓优化的事件总线，简化了活动、片段、线程、服务等的通信&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/otto&quot;&gt;Otto&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个基于Guava的增强的事件总线&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-10&quot;&gt;11. 响应式编程&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;JVM上的响应式扩展&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJavaJoins&quot;&gt;RxJavaJoins&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;为RxJava提供Joins操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot;&gt;RxAndroid&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android上的响应式扩展，在RxJava基础上添加了Android线程调度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/JakeWharton/RxBinding&quot;&gt;RxBinding&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;提供用RxJava绑定Android UI的API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/google/agera&quot;&gt;Agera&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android上的响应式编程&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;log&quot;&gt;12. Log框架&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/orhanobut/logger&quot;&gt;Logger&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;简单，漂亮，强大的Android日志工具&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/JakeWharton/hugo&quot;&gt;Hugo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;在调试版本上注解的触发方法进行日志记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/JakeWharton/timber&quot;&gt;Timber&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;一个小的，可扩展的日志工具&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-11&quot;&gt;13. 测试框架&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/mockito/mockito&quot;&gt;Mockito&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Java编写的Mocking单元测试框架&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/RobotiumTech/robotium&quot;&gt;Robotium&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android UI 测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/xtremelabs/robolectric&quot;&gt;Robolectric&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android单元测试框架&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;14. 调试框架&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/stetho&quot;&gt;Stetho&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-13&quot;&gt;15. 性能优化&lt;/h3&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/square/leakcanary&quot;&gt;LeakCanary&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;内存泄漏检测工具&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ACRA/acra&quot;&gt;ACRA&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Android应用程序崩溃报告&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 17 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/17/android_frame_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/17/android_frame_introduction/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>ios 进阶篇</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;p&gt;对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。&lt;/p&gt;

&lt;p&gt;一图以蔽之&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ios_introduction/ios_image_note50592_1.png&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再简单些说：&lt;strong&gt;浅复制就是指针拷贝；深复制就是内容拷贝&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;shallow-copy&quot;&gt;集合的浅复制 (shallow copy)&lt;/h3&gt;

&lt;p&gt;集合的浅复制有非常多种方法。当你进行浅复制时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。&lt;/p&gt;

&lt;p&gt;现在让我们看一些浅复制的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *shallowCopyArray = [someArray copyWithZone:nil];
NSSet *shallowCopySet = [NSSet mutableCopyWithZone:nil];
NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;deep-copy&quot;&gt;集合的深复制 (deep copy)&lt;/h3&gt;

&lt;p&gt;集合的深复制有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。&lt;/p&gt;

&lt;p&gt;第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;one-level-deep-copy&quot;&gt;集合的单层深复制 (one-level-deep copy)&lt;/h3&gt;

&lt;p&gt;看到这里，有同学会问：如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3&quot;&gt;苹果官网文档&lt;/a&gt;有这样一句话描述&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy...

If you need a true deep copy, such as when you have an array of arrays...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从文中可以看出，苹果认为这种复制不是真正的深复制，而是将其称为&lt;strong&gt;单层深复制(one-level-deep copy)&lt;/strong&gt;。因此，网上有人对浅复制、深复制、单层深复制做了概念区分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;浅复制(shallow copy)：在浅复制操作时，对于被复制对象的每一层都是指针复制。&lt;/li&gt;
  &lt;li&gt;深复制(one-level-deep copy)：在深复制操作时，对于被复制对象，至少有一层是深复制。&lt;/li&gt;
  &lt;li&gt;完全复制(real-deep copy)：在完全复制操作时，对于被复制对象的每一层都是对象复制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这些都是概念性的东西，没有必要纠结于此。只要知道进行拷贝操作时，被拷贝的是指针还是内容即可。&lt;/p&gt;

&lt;h3 id=&quot;copymutablecopy&quot;&gt;系统对象的copy与mutableCopy方法&lt;/h3&gt;

&lt;p&gt;不管是集合类对象，还是非集合类对象，接收到copy和mutableCopy消息时，都遵循以下准则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;copy返回imutable对象；所以，如果对copy返回值使用mutable对象接口就会crash；&lt;/li&gt;
  &lt;li&gt;mutableCopy返回mutable对象；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面将针对非集合类对象和集合类对象的copy和mutableCopy方法进行具体的阐述&lt;/p&gt;

&lt;h4 id=&quot;copymutablecopy-1&quot;&gt;1、非集合类对象的copy与mutableCopy&lt;/h4&gt;

&lt;p&gt;系统非集合类对象指的是 NSString, NSNumber … 之类的对象。下面先看个非集合类immutable对象拷贝的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *string = @&quot;origin&quot;;
NSString *stringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过查看内存，可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；&lt;/p&gt;

&lt;p&gt;再看mutable对象拷贝例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableString *string = [NSMutableString stringWithString: @&quot;origin&quot;];
//copy
NSString *stringCopy = [string copy];
NSMutableString *mStringCopy = [string copy];
NSMutableString *stringMCopy = [string mutableCopy];
//change value
[mStringCopy appendString:@&quot;mm&quot;]; //crash
[string appendString:@&quot; origion!&quot;];
[stringMCopy appendString:@&quot;!!&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行以上代码，会在第7行crash，原因就是 copy 返回的对象是 immutable 对象。注释第7行后再运行，查看内存，发现 string、stringCopy、mStringCopy、stringMCopy 四个对象的内存地址都不一样，说明此时都是做内容拷贝。&lt;/p&gt;

&lt;p&gt;综上两个例子，我们可以得出结论：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：

[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //深复制
[mutableObject copy] //深复制
[mutableObject mutableCopy] //深复制
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;copymutablecopy-2&quot;&gt;2、集合类对象的copy与mutableCopy&lt;/h4&gt;

&lt;p&gt;集合类对象是指NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用copy和mutableCopy的一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;查看内容，可以看到copyArray和array的地址是一样的，而mCopyArray和array的地址是不同的。说明copy操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝array这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合immutable对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看mutable对象拷贝的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;查看内存，如我们所料，copyArray、mCopyArray和array的内存地址都不一样，说明copyArray、mCopyArray都对array进行了内容拷贝。同样，我们可以得出结论：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在集合类对象中，对immutable对象进行copy，是指针复制，mutableCopy是内容复制；对mutable对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：

[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个代码结论和非集合类的非常相似。&lt;/p&gt;

&lt;p&gt;这时候，是不是有人要问了，如果要对集合对象复制元素怎么办？有这疑问的同学不妨回头看看&lt;strong&gt;集合的深复制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;好了，深复制与浅复制就讲到这里。&lt;/p&gt;

&lt;p&gt;最后说个题外的东西，在搜集资料的过程中，发现一个有可能犯错的点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = @&quot;string&quot;;
str = @&quot;newString&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这段代码，在执行第二行代码后，内存地址发生了变化。乍一看，有点意外。按照 C 语言的经验，初始化一个字符串之后，字符串的首地址就被确定下来，不管之后如何修改字符串内容，这个地址都不会改变。但此处第二行并不是对 str 指向的内存地址重新赋值，因为赋值操作符左边的 str 是一个指针，也就是说此处修改的是内存地址。&lt;/p&gt;

&lt;p&gt;所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。&lt;/p&gt;

&lt;p&gt;我有如下的两个方法查看内存地址&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p str&lt;/code&gt;会打印对象本身的内存地址和对象内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) p str
(NSString *) $0 = 0x000000010c913680 @&quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;po &amp;amp;str&lt;/code&gt; 则打印的是引用对象的指针所在的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(lldb) po &amp;amp;str
0x00007fff532fb6c0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 16 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/16/ios_copy_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/16/ios_copy_introduction/</guid>
        
        <category>ios</category>
        
        
      </item>
    
      <item>
        <title>IOS 第三方库管理工具</title>
        <description>&lt;h3 id=&quot;cocoapods&quot;&gt;CocoaPods是什么？&lt;/h3&gt;

&lt;p&gt;当你开发iOS应用时，会经常使用到很多第三方开源类库，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;JSONKit，AFNetWorking&lt;/code&gt;等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要CocoaPods。&lt;/p&gt;

&lt;p&gt;CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。&lt;/p&gt;

&lt;h3 id=&quot;cocoapods-1&quot;&gt;如何下载和安装CocoaPods？&lt;/h3&gt;

&lt;p&gt;在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。&lt;/p&gt;

&lt;p&gt;假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem sources --remove https://rubygems.org/
//等有反应之后再敲入以下命令
$ gem sources -a https://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem sources -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;只有在终端中出现下面文字才表明你上面的命令是成功的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*** CURRENT SOURCES ***

https://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这时候，你再次在终端中运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。&lt;/p&gt;

&lt;h3 id=&quot;cocoapods-2&quot;&gt;如何使用CocoaPods？&lt;/h3&gt;

&lt;p&gt;好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。&lt;/p&gt;

&lt;h4 id=&quot;cocoapodsafnetworking&quot;&gt;场景1：利用CocoaPods，在项目中导入AFNetworking类库&lt;/h4&gt;

&lt;p&gt;AFNetworking类库在GitHub地址是：&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;https://github.com/AFNetworking/AFNetworking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod search AFNetworking
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。&lt;/p&gt;

&lt;p&gt;这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。&lt;/p&gt;

&lt;p&gt;你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。&lt;/p&gt;

&lt;p&gt;好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim Podfile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后在Podfile文件中输入以下文字：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform :ios, &#39;7.0&#39;
pod &quot;AFNetworking&quot;, &quot;~&amp;gt; 2.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后保存退出。vim环境下，保存退出命令是：&lt;code class=&quot;highlighter-rouge&quot;&gt;:wq&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;Podfile文件应该和你的工程文件.xcodeproj&lt;/code&gt;在同一个目录下。&lt;/p&gt;

&lt;p&gt;这时候，你就可以利用CocoPods下载&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;类库了。还是在终端中的当前项目目录下，运行以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。&lt;/p&gt;

&lt;p&gt;运行上述命令之后,终端出现以下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Analyzing dependencies
        Downloading dependencies
        Installing AFNetworking (2.0.2)
        Generating Pods project
        Integrating client project

        [!] From now on use `CocoaPodsDemo.xcworkspace`.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。&lt;/p&gt;

&lt;p&gt;如果需要更新使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上述都只是CocoaPods的最基本用法。要继续研究CocoaPods其他高级用法，请点击这里&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/wiki&quot;&gt;CocoaPods Wiki&lt;/a&gt; 。&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Jun 2016 15:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/15/ios_pod_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/15/ios_pod_introduction/</guid>
        
        <category>ios</category>
        
        
      </item>
    
      <item>
        <title>IOS 快速开发工具</title>
        <description>&lt;h3 id=&quot;alcatraz&quot;&gt;第一部分 Alcatraz插件的介绍&lt;/h3&gt;

&lt;p&gt;Alcatraz 是Xcode管理插件的工具,在上面能找到各种提高效率的插件。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin&quot;&gt;https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装的方法也很简单，如果你以前没有安装过那执行下面指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -fsSL https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果之前安装过但是Xcode最新版本不能用了，那就先卸载旧的再安装下新的。&lt;/p&gt;

&lt;p&gt;卸载的方法是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin
rm -rf ~/Library/Application\ Support/Alcatraz/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;第二部分 插件的安装&lt;/h3&gt;

&lt;p&gt;in Xcode: &lt;code class=&quot;highlighter-rouge&quot;&gt;go to Windows → Package Manager&lt;/code&gt; and search for &lt;code class=&quot;highlighter-rouge&quot;&gt;插件名&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/70505dece9a75af5ca4715fff66271127f7d5b78/687474703a2f2f616c63617472617a2e696f2f696d616765732f6d656e754032782e706e67&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第三部分 插件的汇总&lt;/h3&gt;

&lt;h4 id=&quot;esjsonformat-xcode&quot;&gt;ESJsonFormat-Xcode&lt;/h4&gt;

&lt;p&gt;ESJsonFormat-Xcode 是Xcode JSON格式化输出为模型的属性的插件。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/EnjoySR/ESJsonFormat-Xcode&quot;&gt;https://github.com/EnjoySR/ESJsonFormat-Xcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/EnjoySR/ESJsonFormat-Xcode/master/ScreenShot/ScreenShot2.gif&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;mlautoreplace&quot;&gt;MLAutoReplace&lt;/h4&gt;

&lt;p&gt;MLAutoReplace make you write code more quickly.&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/molon/MLAutoReplace&quot;&gt;https://github.com/molon/MLAutoReplace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/molon/MLAutoReplace/master/replaceTS.gif&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;vvdocumenter-xcode&quot;&gt;VVDocumenter-Xcode&lt;/h4&gt;

&lt;p&gt;VVDocumenter 是一个Xcode的代码注释框架，可以简单的操作三斜杠&lt;code class=&quot;highlighter-rouge&quot;&gt;///&lt;/code&gt;即可生成对应的代码注释，在菜单Window中找到VVDocumenter 可以进行一些个性化的设置。总体来说还是非常实用和好用的。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot;&gt;https://github.com/onevcat/VVDocumenter-Xcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;ksimagenamed&quot;&gt;KSImageNamed&lt;/h4&gt;

&lt;p&gt;KSImageNamed 是一款Xcode 图片文件提示工具.当你输入&lt;code class=&quot;highlighter-rouge&quot;&gt;imageNamed: &lt;/code&gt;的时候会弹出所有图片的名称和预览图片选择，。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/ksuther/KSImageNamed-Xcode&quot;&gt;https://github.com/ksuther/KSImageNamed-Xcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c354bf04524df86daeabe7a6d2b9926fac790f85/68747470733a2f2f7261772e6769746875622e636f6d2f6b7375746865722f4b53496d6167654e616d65642d58636f64652f6d61737465722f73637265656e73686f742e676966&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;scxcodeminimap&quot;&gt;SCXcodeMiniMap&lt;/h4&gt;

&lt;p&gt;SCXcodeMiniMap 是Xcode中类似于sublime的功能，这是非常好用的。 并且右边的代码迷你地图提供了很多可配置的地方，而且会高亮显示宏和注释部分，小地图中点击任何地方也会自动滚动至此。这在有的类代码特别长时你写着写着都不知道自己在哪里了,会很有用.&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/stefanceriu/SCXcodeMiniMap&quot;&gt;https://github.com/stefanceriu/SCXcodeMiniMap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/dff11be450a7e4f0208950a00b218484fffdac5b/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f31323734383230312f5265636f7264696e67732f534358636f64654d696e696d61702f76322e322f736561726368526573756c7473486967686c69676874696e672e706e67&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;bbudebuggertuckaway&quot;&gt;BBUDebuggerTuckAway&lt;/h4&gt;

&lt;p&gt;BBUDebuggerTuckAway 在Xcode编辑代码的时候，调试框会自动缩回。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/neonichu/BBUDebuggerTuckAway&quot;&gt;https://github.com/neonichu/BBUDebuggerTuckAway&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/neonichu/BBUDebuggerTuckAway/raw/master/plugin.gif&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;cocoapods-xcode-plugin&quot;&gt;cocoapods-xcode-plugin&lt;/h4&gt;

&lt;p&gt;cocoapods-xcode-plugin 是一个Xcode上Pod管理工具。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/kattrali/cocoapods-xcode-plugin&quot;&gt;https://github.com/kattrali/cocoapods-xcode-plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kattrali/cocoapods-xcode-plugin/raw/master/menu.png&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;scxcodeswitchexpander&quot;&gt;SCXcodeSwitchExpander&lt;/h4&gt;

&lt;p&gt;SCXcodeSwitchExpander  是Xcode非常方便的创建枚举库，自动生成了所有可能，并且每种里面都包含代码块，可以直接tab切换。  虽然使用率不会特别高但是用到的时候还是非常方便的。&lt;/p&gt;

&lt;p&gt;源码地址： &lt;a href=&quot;https://github.com/stefanceriu/SCXcodeSwitchExpander&quot;&gt;https://github.com/stefanceriu/SCXcodeSwitchExpander&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/a544a54d43b6e26c75d56889b7a6a4df8a90b4a5/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f31323734383230312f534358636f6465537769746368457870616e6465722f534358636f6465537769746368457870616e646572322e676966&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;hostringsense&quot;&gt;HOStringSense&lt;/h4&gt;

&lt;p&gt;HOStringSense 是Xcode内容编辑工具，会把换行，空格转化成代码片段。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/holtwick/HOStringSense-for-Xcode&quot;&gt;https://github.com/holtwick/HOStringSense-for-Xcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;xalign&quot;&gt;XAlign&lt;/h4&gt;

&lt;p&gt;XAlign 是Xcode中自动对齐库,可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode -&amp;gt; Edit -&amp;gt; XAlign&lt;/code&gt; 设置快捷键。默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shift + Cmd + X&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/qfish/XAlign&quot;&gt;https://github.com/qfish/XAlign&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7973c0e352b1f91e3efe5b3550cff5df97f4589a/687474703a2f2f7166692e73682f58416c69676e2f696d616765732f657175616c2e676966&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;dash-plugin-for-xcode&quot;&gt;Dash-Plugin-for-Xcode&lt;/h4&gt;

&lt;p&gt;Dash-Plugin-for-Xcode 是Bogdan Popescu开发的一款集成了Dash文档查看器应用的Xcode插件，允许开发者在使用Option-Click或作用相同的快捷键操作查看当前文本的相关文档时，用Dash代替Xcode的文档查看器。&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/omz/Dash-Plugin-for-Xcode&quot;&gt;https://github.com/omz/Dash-Plugin-for-Xcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;peckham&quot;&gt;Peckham&lt;/h4&gt;

&lt;p&gt;Peckham 是Xcode快速导入头文件的插件,默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘ + ctrl + P&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/markohlebar/Peckham&quot;&gt;https://github.com/markohlebar/Peckham&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/markohlebar/Peckham/raw/master/Misc/Peckham.gif&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;xtodo-xcode&quot;&gt;XToDo-Xcode&lt;/h4&gt;

&lt;p&gt;XToDo-Xcode 是一个注释辅助插件, 可以把项目中的 TODO FIXME等注释列出来.&lt;/p&gt;

&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/trawor/XToDo&quot;&gt;https://github.com/trawor/XToDo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/trawor/XToDo/raw/master/screenshots/2.png&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Jun 2016 20:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/14/ios_xcodeplu_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/14/ios_xcodeplu_introduction/</guid>
        
        <category>ios</category>
        
        <category>Xcode</category>
        
        
      </item>
    
      <item>
        <title>Android 快速开发工具</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;第一部分 插件的介绍&lt;/h3&gt;

&lt;p&gt;Google 在2013年5月的I/O开发者大会推出了基于&lt;code class=&quot;highlighter-rouge&quot;&gt;IntelliJ IDEA java ide&lt;/code&gt;上的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;是一个功能齐全的开发工具，还提供了第三方插件的支持。让开发人员更快速更好的开发程序。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第二部分 插件的安装&lt;/h3&gt;

&lt;p&gt;in Android Studio: &lt;code class=&quot;highlighter-rouge&quot;&gt;go to File → Settings → Plugins → Browse repositories&lt;/code&gt; and search for &lt;code class=&quot;highlighter-rouge&quot;&gt;插件名&lt;/code&gt; or in Android Studio: go to download it jar and install &lt;code class=&quot;highlighter-rouge&quot;&gt;File → Settings → Plugins → Install plugin from disk&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第三部分 插件的汇总&lt;/h3&gt;

&lt;h4 id=&quot;android-butterknife-zelezny&quot;&gt;Android ButterKnife Zelezny&lt;/h4&gt;

&lt;p&gt;ButterKnife是一个专注于Android系统的View注入框架,可以减少大量的findViewById以及setOnClickListener代码，可视化一键生成。PS:效果图就不贴了，打开插件下载地址和源码地址都能看见，而且据多了加载效果图蛮卡的。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7369?pr=androidstudio&quot;&gt;https://plugins.jetbrains.com/plugin/7369?pr=androidstudio&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址： &lt;a href=&quot;https://github.com/avast/android-butterknife-zelezny&quot;&gt;https://github.com/avast/android-butterknife-zelezny&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程： &lt;a href=&quot;http://blog.csdn.net/dreamlivemeng/article/details/51261170&quot;&gt;http://blog.csdn.net/dreamlivemeng/article/details/51261170&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;gsonformat&quot;&gt;GsonFormat&lt;/h4&gt;

&lt;p&gt;GsonFormat是一个快速格式化json数据,自动生成实体类参数的插件。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7654?pr=androidstudio&quot;&gt;https://plugins.jetbrains.com/plugin/7654?pr=androidstudio&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/zzz40500/GsonFormat&quot;&gt;https://github.com/zzz40500/GsonFormat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程：&lt;a href=&quot;http://blog.csdn.net/dreamlivemeng/article/details/51262538&quot;&gt;http://blog.csdn.net/dreamlivemeng/article/details/51262538&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-drawable-importer&quot;&gt;Android Drawable Importer&lt;/h4&gt;

&lt;p&gt;为了适应所有Android屏幕的大小和密度，每个Android项目都会包含drawable文件夹。任何具备Android开发经验的开发人员都知道，为了支持所有的屏幕尺寸，你必须给每个屏幕类型导入不同的画板。Android Drawable Importer插件能让这项工作变得更容易。它可以减少导入缩放图像到Android项目所需的工作量。Android Drawable Importer添加了一个在不同分辨率导入画板或缩放指定图像到定义分辨率的选项。这个插件加速了开发人员的画板工作。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7658?pr=androidstudio&quot;&gt;https://plugins.jetbrains.com/plugin/7658?pr=androidstudio&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/winterDroid/android-drawable-importer-intellij-plugin&quot;&gt;https://github.com/winterDroid/android-drawable-importer-intellij-plugin
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程地址：&lt;a href=&quot;http://blog.csdn.net/lee_sire/article/details/49684385&quot;&gt;http://blog.csdn.net/lee_sire/article/details/49684385&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-selector-chapek--selectorchapek-for-android&quot;&gt;android-selector-chapek / SelectorChapek for Android&lt;/h4&gt;

&lt;p&gt;根据资源自动生成相应的selector。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7298&quot;&gt;https://plugins.jetbrains.com/plugin/7298&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/inmite/android-selector-chapek&quot;&gt;https://github.com/inmite/android-selector-chapek&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-parcelable-code-generator&quot;&gt;Android Parcelable code generator&lt;/h4&gt;

&lt;p&gt;快速实现Parcelable接口的插件。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7332?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7332?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/mcharmas/android-parcelable-intellij-plugin/&quot;&gt;https://github.com/mcharmas/android-parcelable-intellij-plugin/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程地址：&lt;a href=&quot;http://blog.csdn.net/kroclin/article/details/40902721&quot;&gt;http://blog.csdn.net/kroclin/article/details/40902721&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;markdown&quot;&gt;Markdown&lt;/h4&gt;

&lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/5970?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/5970?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件文档地址：&lt;a href=&quot;https://github.com/nicoulaj/idea-markdown&quot;&gt;https://github.com/nicoulaj/idea-markdown&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-postfix-completion&quot;&gt;Android Postfix completion&lt;/h4&gt;

&lt;p&gt;可根据后缀快速完成代码。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7775?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7775?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程地址：&lt;a href=&quot;http://blog.jetbrains.com/idea/2014/03/postfix-completion/&quot;&gt;http://blog.jetbrains.com/idea/2014/03/postfix-completion/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;androidaccessors&quot;&gt;AndroidAccessors&lt;/h4&gt;

&lt;p&gt;快速实现get和set方法的插件。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7496?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7496?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件文档地址：&lt;a href=&quot;https://github.com/jonstaff/AndroidAccessors&quot;&gt;https://github.com/jonstaff/AndroidAccessors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：三星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;lifecycle-sorter&quot;&gt;Lifecycle Sorter&lt;/h4&gt;

&lt;p&gt;可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7742?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7742?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/armandAkop/Lifecycle-Sorter&quot;&gt;https://github.com/armandAkop/Lifecycle-Sorter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;adb-wifi-rootwifi&quot;&gt;ADB WIFI 无需root就能wifi调试。&lt;/h4&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7856?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7856?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/layerlre/ADBWIFI&quot;&gt;https://github.com/layerlre/ADBWIFI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数： 五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;adb-idea&quot;&gt;ADB Idea&lt;/h4&gt;

&lt;p&gt;adb 调试工具,Uninstall App、Kill App、Start App、Restart App、Clear App Data、Clear App Data and Restart&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7380?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7380?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/pbreault/adb-idea/&quot;&gt;https://github.com/pbreault/adb-idea/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;codeglance&quot;&gt;CodeGlance&lt;/h4&gt;

&lt;p&gt;最大的用途：可用于快速定位代码。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7275?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7275?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/Vektah/CodeGlance&quot;&gt;https://github.com/Vektah/CodeGlance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;jsononlineviewer&quot;&gt;JSONOnlineViewer&lt;/h4&gt;

&lt;p&gt;可实现直接在android studio中调试接口数据，可以选择请求类型，自定义请求头及请求体，json数据格式化后展示&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7838?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7838?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;findbugs-idea&quot;&gt;FindBugs-IDEA&lt;/h4&gt;

&lt;p&gt;通过FindBugs帮你找到隐藏的bug及不好的做法。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/3847?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/3847?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/andrepdo/findbugs-idea/tree/master&quot;&gt;https://github.com/andrepdo/findbugs-idea/tree/master&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;jimu-mirror&quot;&gt;jimu Mirror&lt;/h4&gt;

&lt;p&gt;这是一个可以让你在真实的设备上迅速测试布局的插件。jimu Mirror允许在设备上预览随同编码更新的Android布局。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7517?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7517?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件教程地址：&lt;a href=&quot;http://www.itnose.net/detail/6204426.html&quot;&gt;http://www.itnose.net/detail/6204426.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;javadoc&quot;&gt;JavaDoc&lt;/h4&gt;

&lt;p&gt;添加注释，可自定义模板。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/?idea_ce&amp;amp;pluginId=7157&quot;&gt;https://plugins.jetbrains.com/plugin/?idea_ce&amp;amp;pluginId=7157&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/setial/intellij-javadocs&quot;&gt;https://github.com/setial/intellij-javadocs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数： 五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-stringsxml-tools&quot;&gt;Android strings.xml tools&lt;/h4&gt;

&lt;p&gt;可以用来管理Android项目中的字符串资源。它提供了排序Android本地文件和添加缺少的字符串的基本操作。虽然这个插件是有限制的，但如果应用程序有大量的字符串资源，那这个插件就非常有用了。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7498?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7498?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/constantine-ivanov/strings-xml-tools&quot;&gt;https://github.com/constantine-ivanov/strings-xml-tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;robotium-recorder&quot;&gt;Robotium Recorder&lt;/h4&gt;

&lt;p&gt;Robotium Recorder是一个自动化测试框架，用于测试在模拟器和Android设备上原生的和混合的移动应用程序。Robotium Recorder可以让你记录测试案例和用户操作。你也可以查看不同Android活动时的系统功能和用户测试场景。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7513?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7513?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件官方网址：&lt;a href=&quot;http://robotium.com/&quot;&gt;http://robotium.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-holo-colors-generator&quot;&gt;Android Holo Colors Generator&lt;/h4&gt;

&lt;p&gt;通过自定义Holo主题颜色生成对应的Drawable和布局文件&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7366?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7366?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/jeromevdl/android-holo-colors-idea-plugin&quot;&gt;https://github.com/jeromevdl/android-holo-colors-idea-plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;lint-cleaner-plugin&quot;&gt;lint-cleaner-plugin&lt;/h4&gt;

&lt;p&gt;删除未使用的资源,包括String字符串,颜色和尺寸。 这是一个Gradle插件，所以如何配置可以去github的源码上看。&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/marcoRS/lint-cleaner-plugin&quot;&gt;https://github.com/marcoRS/lint-cleaner-plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;codota&quot;&gt;codota&lt;/h4&gt;

&lt;p&gt;该网站搜集了大量的代码，号称超过700W的代码实例。提供了chrome和as插件。&lt;/p&gt;

&lt;p&gt;插件下载地址：&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7638?pr=&quot;&gt;https://plugins.jetbrains.com/plugin/7638?pr=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插件官方网址：&lt;a href=&quot;https://www.codota.com/&quot;&gt;https://www.codota.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：五星&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;ectranslation&quot;&gt;ECTranslation&lt;/h4&gt;

&lt;p&gt;一个androidstudio上面的翻译插件（将英文翻译为中文）。 暂时只能以jar的方式安装。jar下载地址以及使用方法在github上的源码地址上都有详细描述。&lt;/p&gt;

&lt;p&gt;插件源码地址：&lt;a href=&quot;https://github.com/Skykai521/ECTranslation&quot;&gt;https://github.com/Skykai521/ECTranslation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐指数：四星&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/13/android_studio_plugins_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/13/android_studio_plugins_introduction/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>IOS 炫酷框架</title>
        <description>&lt;h3 id=&quot;pophttpsgithubcomfacebookpop&quot;&gt;&lt;a href=&quot;https://github.com/facebook/pop&quot;&gt;pop&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/facebook/pop/blob/master/Images/pop.gif?raw=true&quot; alt=&quot;pop&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;poppinghttpsgithubcomschneiderandrepopping&quot;&gt;&lt;a href=&quot;https://github.com/schneiderandre/popping&quot;&gt;popping&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/6ab14f37121c61a4b568c38376f0e24984d1aad8/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f31393135303330302f4769746875622f506f7070696e672f706f7070696e672e706e67&quot; alt=&quot;popping&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/a7a98afd238fd3e51d50af8389e6c2dfc3577d45/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f31393135303330302f4769746875622f506f7070696e672f706f7070696e672e676966&quot; alt=&quot;popping&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;springhttpsgithubcommengtospring&quot;&gt;&lt;a href=&quot;https://github.com/MengTo/Spring&quot;&gt;Spring&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://cl.ly/image/3a1r1d3l3D1j/spring-logo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cl.ly/image/241o0G1G3S36/download/springsetup.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cl.ly/image/1n1E2j3W3y24/springscreen.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jnwspringanimationhttpsgithubcomjwillingjnwspringanimation&quot;&gt;&lt;a href=&quot;https://github.com/jwilling/JNWSpringAnimation&quot;&gt;JNWSpringAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jwilling.com/serve/github/jnwspringanimation/preview.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dcanimationkithttpsgithubcomdaltoniamdcanimationkit&quot;&gt;&lt;a href=&quot;https://github.com/daltoniam/DCAnimationKit&quot;&gt;DCAnimationKit&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Tada&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/tada.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bounce&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/bounce.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pulse&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/pulse.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Shake&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/shake.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Swing&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/swing.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Snap&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/snapin.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bounce&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/bouncein.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expand&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/expandin.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Compress&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/compressin.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hinge&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/hinge.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Drop&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/drop.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Move&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/slide.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rotation&lt;/strong&gt;
&lt;img src=&quot;https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/rotate.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rbbanimationhttpsgithubcomrobbrbbanimation&quot;&gt;&lt;a href=&quot;https://github.com/robb/RBBAnimation&quot;&gt;RBBAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://robb.is/img/rbbanimation/rainbow.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://robb.is/img/rbbanimation/spring.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://robb.is/img/rbbanimation/ease-in-out-back.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://robb.is/img/rbbanimation/bounce.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://robb.is/img/rbbanimation/sine-wave.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pop-mcanimatehttpsgithubcommatthewcheokpop-mcanimate&quot;&gt;&lt;a href=&quot;https://github.com/matthewcheok/POP-MCAnimate&quot;&gt;POP-MCAnimate&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;jhchainableanimationshttpsgithubcomjhurrayjhchainableanimations&quot;&gt;&lt;a href=&quot;https://github.com/jhurray/JHChainableAnimations&quot;&gt;JHChainableAnimations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/jhurray/JHChainableAnimations/raw/master/img/logo.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/jhurray/JHChainableAnimations/master/img/JHChainableAnimationsExample1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/jhurray/JHChainableAnimations/master/Gifs/JHChainableAnimationsExample1.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://github.com/jhurray/JHChainableAnimations/raw/master/img/JHChainableAnimationsExample2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://github.com/jhurray/JHChainableAnimations/raw/master/Gifs/JHChainableAnimationsExample2.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://github.com/jhurray/JHChainableAnimations/raw/master/img/JHChainableAnimationsExample3.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://github.com/jhurray/JHChainableAnimations/raw/master/Gifs/JHChainableAnimationsExample3.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pmtweenhttpsgithubcompoetmountainpmtween&quot;&gt;&lt;a href=&quot;https://github.com/poetmountain/PMTween&quot;&gt;PMTween&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;jazzhandshttpsgithubcomiftttjazzhands&quot;&gt;&lt;a href=&quot;https://github.com/IFTTT/JazzHands&quot;&gt;JazzHands&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.github.com/IFTTT/JazzHands/screenshots/screenshots/intro.gif&quot; alt=&quot;Jazz Hands&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;animatedtransitiongalleryhttpsgithubcomshu223animatedtransitiongallery&quot;&gt;&lt;a href=&quot;https://github.com/shu223/AnimatedTransitionGallery&quot;&gt;AnimatedTransitionGallery&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/gallery.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/coreimage.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/motionblur.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/boxblur.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rztransitionshttpsgithubcomraizlabsrztransitions&quot;&gt;&lt;a href=&quot;https://github.com/Raizlabs/RZTransitions&quot;&gt;RZTransitions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Raizlabs/RZTransitions/master/Web/RZTransitions.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://raw.github.com/Raizlabs/RZTransitions/master/Web/RZTransitionsDemo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;foldingtabbarioshttpsgithubcomyalantisfoldingtabbarios&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/FoldingTabBar.iOS&quot;&gt;FoldingTabBar.iOS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/495792/screenshots/2003376/tab_bar_animation_fin-02.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;side-menuioshttpsgithubcomyalantisside-menuios&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Side-Menu.iOS&quot;&gt;Side-Menu.iOS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1689922/events-menu_1-1-6.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;context-menuioshttpsgithubcomyalantiscontext-menuios&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Context-Menu.iOS&quot;&gt;Context-Menu.iOS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1785274/99miles-profile-light_1-1-4.gif&quot; alt=&quot;ContextMenu&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;guillotinemenuhttpsgithubcomyalantisguillotinemenu&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/GuillotineMenu&quot;&gt;GuillotineMenu&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/495792/screenshots/2018249/draft_06.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;perseihttpsgithubcomyalantispersei&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Persei&quot;&gt;Persei&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/Persei/master/Assets/animation.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pull-to-refreshrentals-ioshttpsgithubcomyalantispull-to-refreshrentals-ios&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Pull-to-Refresh.Rentals-iOS&quot;&gt;Pull-to-Refresh.Rentals-iOS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1650317/realestate-pull_1-2-3.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pulltomakesouphttpsgithubcomyalantispulltomakesoup&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/PullToMakeSoup&quot;&gt;PullToMakeSoup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/PullToMakeSoup/master/PullToMakeSoupDemo/Resouces/recipe-finder.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pulltomakeflighthttpsgithubcomyalantispulltomakeflight&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/PullToMakeFlight&quot;&gt;PullToMakeFlight&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/PullToMakeFlight/master/PullToMakeFlightDemo/Resources/tours-pull-airplane.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kolodahttpsgithubcomyalantiskoloda&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Koloda&quot;&gt;Koloda&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Yalantis/Koloda/blob/master/Koloda_v2_example_animation.gif&quot; alt=&quot;Preview&quot; /&gt;
&lt;img src=&quot;https://github.com/Yalantis/Koloda/blob/master/Koloda_v1_example_animation.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;starwarsioshttpsgithubcomyalantisstarwarsios&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/StarWars.iOS&quot;&gt;StarWars.iOS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://yalantis-com.s3.amazonaws.com/uploads/ckeditor/pictures/49/content_star_wars-shot__1_.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;eatfithttpsgithubcomyalantiseatfit&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/EatFit&quot;&gt;EatFit&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://yalantis.com/media/content/ckeditor/2015/09/30/charts-animation.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;preloaderophiuchushttpsgithubcomyalantispreloaderophiuchus&quot;&gt;&lt;a href=&quot;https://github.com/Yalantis/Preloader.Ophiuchus&quot;&gt;Preloader.Ophiuchus&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/yalantistwodirections.gif&quot; alt=&quot;Yalantis&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/animation.gif&quot; alt=&quot;Preview&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/thegreenhorse.gif&quot; alt=&quot;The Green Horse&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;animated-tab-barhttpsgithubcomramotionanimated-tab-bar&quot;&gt;&lt;a href=&quot;https://github.com/Ramotion/animated-tab-bar&quot;&gt;animated-tab-bar&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Ramotion/animated-tab-bar/master/Screenshots/tab-bar-icons-iphone-ramotion-animation-interface-design.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;bubbletransitionhttpsgithubcomandreamazzbubbletransition&quot;&gt;&lt;a href=&quot;https://github.com/andreamazz/BubbleTransition&quot;&gt;BubbleTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/BubbleTransition/master/assets/logo.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/BubbleTransition/master/assets/screenshot.gif&quot; alt=&quot;BubbleTransition&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ios-bubble-transitionhttpsgithubcomfitomadios-bubble-transition&quot;&gt;&lt;a href=&quot;https://github.com/fitomad/iOS-Bubble-Transition&quot;&gt;iOS-Bubble-Transition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/fitomad/iOS-Bubble-Transition/blob/master/Bubble.gif?raw=true&quot; alt=&quot;Bubble Transition&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cnppopupcontrollerhttpsgithubcomcarsonperrotticnppopupcontroller&quot;&gt;&lt;a href=&quot;https://github.com/carsonperrotti/CNPPopupController&quot;&gt;CNPPopupController&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/carsonperrotti/CNPPopupController/master/CNPPopupControllerExample/CNPPopupController.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;giftcard-implementationhttpsgithubcommartinrgbgiftcard-implementation&quot;&gt;&lt;a href=&quot;https://github.com/MartinRGB/GiftCard-Implementation&quot;&gt;GiftCard-Implementation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/MartinRGB/GiftCard-Implementation/blob/master/Gif/Origami.gif?raw=true&quot; alt=&quot;origami&quot; /&gt;
&lt;img src=&quot;https://github.com/MartinRGB/GiftCard-Implementation/blob/master/Gif/Xcode.gif?raw=true&quot; alt=&quot;xcode&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dkchainableanimationkithttpsgithubcomdravenessdkchainableanimationkit&quot;&gt;&lt;a href=&quot;https://github.com/Draveness/DKChainableAnimationKit&quot;&gt;DKChainableAnimationKit&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/DKChainableAnimationKit.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Code1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Demo1.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Code2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Demo2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tindersimpleswipecardshttpsgithubcomcwrichardkimtindersimpleswipecards&quot;&gt;&lt;a href=&quot;https://github.com/cwRichardKim/TinderSimpleSwipeCards&quot;&gt;TinderSimpleSwipeCards&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://imgur.com/4bYw12e.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/krDNpR0.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/W4bIRkc.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/3yk6aiS.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/IIFVkm4.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/j1ISIq5.gif&quot; alt=&quot;alt tag&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/PQYs4sH.gif&quot; alt=&quot;alt tag&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jtmaterialtransitionhttpsgithubcomjonathantribouharetjtmaterialtransition&quot;&gt;&lt;a href=&quot;https://github.com/jonathantribouharet/JTMaterialTransition&quot;&gt;JTMaterialTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jonathantribouharet/JTMaterialTransition/master/Screens/example.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;watchtransitionhttpsgithubcomkongtomorrowwatchtransition&quot;&gt;&lt;a href=&quot;https://github.com/kongtomorrow/WatchTransition&quot;&gt;WatchTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kongtomorrow/WatchTransition/raw/master/WatchFaceTransition.gif&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kypushtransitionhttpsgithubcomkittenyangkypushtransition&quot;&gt;&lt;a href=&quot;https://github.com/KittenYang/KYPushTransition&quot;&gt;KYPushTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/KittenYang/KYPushTransition/master/demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;uiview-shakehttpsgithubcomandreamazzuiview-shake&quot;&gt;&lt;a href=&quot;https://github.com/andreamazz/UIView-Shake&quot;&gt;UIView-Shake&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/UIView-Shake/master/assets/logo.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/UIView-Shake/master/assets/screenshot.gif&quot; alt=&quot;UIView+Shake&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;uitextfield-shakehttpsgithubcomandreamazzuitextfield-shake&quot;&gt;&lt;a href=&quot;https://github.com/andreamazz/UITextField-Shake&quot;&gt;UITextField-Shake&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/UITextField-Shake/master/assets/logo.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/UITextField-Shake/master/assets/screenshot.gif&quot; alt=&quot;UITextField+Shake&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rmpzoomtransitionanimatorhttpsgithubcomrecruit-mprmpzoomtransitionanimator&quot;&gt;&lt;a href=&quot;https://github.com/recruit-mp/RMPZoomTransitionAnimator&quot;&gt;RMPZoomTransitionAnimator&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/recruit-mp/RMPZoomTransitionAnimator/master/docs/collectionview.gif&quot; alt=&quot;Screen shot&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/recruit-mp/RMPZoomTransitionAnimator/master/docs/tableview.gif&quot; alt=&quot;Screen shot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;popmenuhttpsgithubcomxhzengaibpopmenu&quot;&gt;&lt;a href=&quot;https://github.com/xhzengAIB/PopMenu&quot;&gt;PopMenu&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/xhzengAIB/LearnEnglish/raw/master/Screenshots/XHSinaMenuViewExample.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;zfdragablemodaltransitionhttpsgithubcomzoonoozzfdragablemodaltransition&quot;&gt;&lt;a href=&quot;https://github.com/zoonooz/ZFDragableModalTransition&quot;&gt;ZFDragableModalTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zoonooz/ZFDragableModalTransition/master/Screenshot/ss.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mcmheaderanimatedhttpsgithubcommathcarignanimcmheaderanimated&quot;&gt;&lt;a href=&quot;https://github.com/mathcarignani/MCMHeaderAnimated&quot;&gt;MCMHeaderAnimated&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mathcarignani/MCMHeaderAnimated/master/demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rubberbandeffecthttpsgithubcomproduktrubberbandeffect&quot;&gt;&lt;a href=&quot;https://github.com/Produkt/RubberBandEffect&quot;&gt;RubberBandEffect&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Produkt/RubberBandEffect/master/Others/RubberBand_01.gif&quot; alt=&quot;rubber-band01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Produkt/RubberBandEffect/master/Others/RubberBand_02.gif&quot; alt=&quot;rubber-band02&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;easyanimationhttpsgithubcomicanzilbeasyanimation&quot;&gt;&lt;a href=&quot;https://github.com/icanzilb/EasyAnimation&quot;&gt;EasyAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/EA.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/moveX.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/corners.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/spring.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/chain.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mmtweenanimationhttpsgithubcomadad184mmtweenanimation&quot;&gt;&lt;a href=&quot;https://github.com/adad184/MMTweenAnimation&quot;&gt;MMTweenAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/adad184/MMTweenAnimation/master/Images/demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gearrefreshcontrolhttpsgithubcomandreamazzgearrefreshcontrol&quot;&gt;&lt;a href=&quot;https://github.com/andreamazz/GearRefreshControl&quot;&gt;GearRefreshControl&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/andreamazz/GearRefreshControl/master/assets/screenshot.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dragdropcollectionviewhttpsgithubcomliornndragdropcollectionview&quot;&gt;&lt;a href=&quot;https://github.com/LiorNn/DragDropCollectionView&quot;&gt;DragDropCollectionView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LiorNn/DragDropCollectionView/master/demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;twitterbirdanimationhttpsgithubcomrounaktwitterbirdanimation&quot;&gt;&lt;a href=&quot;https://github.com/rounak/TwitterBirdAnimation&quot;&gt;TwitterBirdAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://media.tumblr.com/10cc0ba92377a2cba9fb35c9943fd2ca/tumblr_inline_n6zpokNxpC1qh9cw7.gif&quot; alt=&quot;twitter bird animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;singlelineshakeanimationhttpsgithubcomhaaakonsinglelineshakeanimation&quot;&gt;&lt;a href=&quot;https://github.com/haaakon/SingleLineShakeAnimation&quot;&gt;SingleLineShakeAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haaakon/SingleLineShakeAnimation/master/example.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rqshinelabelhttpsgithubcomzipmerqshinelabel&quot;&gt;&lt;a href=&quot;https://github.com/zipme/RQShineLabel&quot;&gt;RQShineLabel&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zipme/RQShineLabel/master/Screenshots/rqshinelabel.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ltmorphinglabelhttpsgithubcomlexrusltmorphinglabel&quot;&gt;&lt;a href=&quot;https://github.com/lexrus/LTMorphingLabel&quot;&gt;LTMorphingLabel&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3491822/96bf5de6-059d-11e4-9826-a6f82025d1af.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3491838/ffc5aff2-059d-11e4-970c-6e2d7664785a.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3491840/173c2238-059e-11e4-9b33-dcd21edae9e2.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3491845/29bb0f8c-059e-11e4-9ef8-de56bec1baba.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3508789/31e9fafe-0690-11e4-9a76-ba3ef45eb53a.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3582586/4fb8c52e-0bfe-11e4-9b6f-f070f7f3ab55.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://cloud.githubusercontent.com/assets/219689/3594949/815cd3e8-0caa-11e4-9738-278a9c959478.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;wzdraggableswitchheaderviewhttpsgithubcomwongzigiiwzdraggableswitchheaderview&quot;&gt;&lt;a href=&quot;https://github.com/wongzigii/WZDraggableSwitchHeaderView&quot;&gt;WZDraggableSwitchHeaderView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wongzigii/WZDraggableSwitchHeaderView/master/GIF/WZAnimatingTransition.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;zlswipeableviewswifthttpsgithubcomzhxnlaizlswipeableviewswift&quot;&gt;&lt;a href=&quot;https://github.com/zhxnlai/ZLSwipeableViewSwift&quot;&gt;ZLSwipeableViewSwift&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/animation.gif&quot; alt=&quot;direction&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/swipe.gif&quot; alt=&quot;direction&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/direction.gif&quot; alt=&quot;direction&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/undo.gif&quot; alt=&quot;direction&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;zlswipeableviewhttpsgithubcomzhxnlaizlswipeableview&quot;&gt;&lt;a href=&quot;https://github.com/zhxnlai/ZLSwipeableView/&quot;&gt;ZLSwipeableView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipe.gif&quot; alt=&quot;swipe&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeCancel.gif&quot; alt=&quot;cancel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeLeft.gif&quot; alt=&quot;swipeLeft&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeLeftRight.gif&quot; alt=&quot;swipeLeftRight&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ckwavecollectionviewtransitionhttpsgithubcomcezarykopaczckwavecollectionviewtransition&quot;&gt;&lt;a href=&quot;https://github.com/CezaryKopacz/CKWaveCollectionViewTransition&quot;&gt;CKWaveCollectionViewTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://i.giphy.com/3o85xyoYepG177Bhte.gif&quot; alt=&quot;anim.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;liquidfloatingactionbuttonhttpsgithubcomyoavltliquidfloatingactionbutton&quot;&gt;&lt;a href=&quot;https://github.com/yoavlt/LiquidFloatingActionButton&quot;&gt;LiquidFloatingActionButton&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yoavlt/LiquidFloatingActionButton/master/Demo/top.gif&quot; alt=&quot;anim.gif&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/yoavlt/LiquidFloatingActionButton/master/Demo/customizable.gif&quot; alt=&quot;anim.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nvactivityindicatorviewhttpsgithubcomninjaproxnvactivityindicatorview&quot;&gt;&lt;a href=&quot;https://github.com/ninjaprox/NVActivityIndicatorView&quot;&gt;NVActivityIndicatorView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ninjaprox/NVActivityIndicatorView/master/Demo.gif&quot; alt=&quot;anim.gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tksubmittransitionhttpsgithubcomentotsutksubmittransition&quot;&gt;&lt;a href=&quot;https://github.com/entotsu/TKSubmitTransition&quot;&gt;TKSubmitTransition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/entotsu/TKSubmitTransition/blob/master/demo.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;http://download.jikexueyuan.com/detail/id/1301&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://download.jikexueyuan.com/File/image/e224fc4d0c362305fa498b371cfac4c9_318513_189_4c21143928442461801bae5ac596c.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;animationshttpsgithubcomkittenyanganimations&quot;&gt;&lt;a href=&quot;https://github.com/KittenYang/Animations&quot;&gt;Animations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/KittenYang/Animations/master/GooeySlideMenu.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kdintroviewhttpsgithubcomlikedankdintroview&quot;&gt;&lt;a href=&quot;https://github.com/likedan/KDIntroView&quot;&gt;KDIntroView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/likedan/KDIntroView/master/Imgs/showup.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;razzledazzlehttpsgithubcomiftttrazzledazzle&quot;&gt;&lt;a href=&quot;https://github.com/IFTTT/RazzleDazzle&quot;&gt;RazzleDazzle&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/IFTTT/RazzleDazzle/master/Example/Docs/razzledazzle-demo.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;presentationhttpsgithubcomhyperoslopresentation&quot;&gt;&lt;a href=&quot;https://github.com/hyperoslo/Presentation&quot;&gt;Presentation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hyperoslo/Presentation/master/Example/Parallax/Images/Parallax-v2.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;uicollectionview-reorderinghttpsgithubcomnshintiouicollectionview-reordering&quot;&gt;&lt;a href=&quot;https://github.com/nshintio/uicollectionview-reordering&quot;&gt;uicollectionview-reordering&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ee5e5999dea79c81a09416a51b1e6cec5de3a193/687474703a2f2f6e7368696e742e696f2f696d616765732f7569636f6c6c656374696f6e766965772d72656f72646572696e672f342e676966&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;uber-video-welcomehttpsgithubcomchinsyouber-video-welcome&quot;&gt;&lt;a href=&quot;https://github.com/chinsyo/uber-video-welcome&quot;&gt;uber-video-welcome&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chinsyo/uber-video-welcome/master/uber-video-welcome.gif&quot; alt=&quot;Demo GIF Animation&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;liquidloaderhttpsgithubcomyoavltliquidloader&quot;&gt;&lt;a href=&quot;https://github.com/yoavlt/LiquidLoader&quot;&gt;LiquidLoader&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;GrowCircle&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yoavlt/LiquidLoader/blob/master/Demo/grow-circle.gif?raw=true&quot; alt=&quot;GrowCircle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GrowLine&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yoavlt/LiquidLoader/blob/master/Demo/grow-line.gif?raw=true&quot; alt=&quot;GrowLine&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dgelasticpulltorefreshhttpsgithubcomgontovnikdgelasticpulltorefresh&quot;&gt;&lt;a href=&quot;https://github.com/gontovnik/DGElasticPullToRefresh&quot;&gt;DGElasticPullToRefresh&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gontovnik/DGElasticPullToRefresh/master/DGElasticPullToRefreshPreview1.gif&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/gontovnik/DGElasticPullToRefresh/master/DGElasticPullToRefreshPreview2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cardanimationhttpsgithubcomseedantecardanimation&quot;&gt;&lt;a href=&quot;https://github.com/seedante/CardAnimation&quot;&gt;CardAnimation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/32399/screenshots/1265487/attachments/173545/secret-project-animation_2x.gif&quot; alt=&quot;Design from Dribble&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;acanimatedtextfieldhttpsgithubcomalexcatchacanimatedtextfield&quot;&gt;&lt;a href=&quot;https://github.com/AlexCatch/ACAnimatedTextField&quot;&gt;ACAnimatedTextField&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/AlexCatch/ACAnimatedTextField/master/misc/preview.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instructionshttpsgithubcomephreadinstructions&quot;&gt;&lt;a href=&quot;https://github.com/ephread/Instructions&quot;&gt;Instructions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/JUlQH9F.gif&quot; alt=&quot;Instructions Demo&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mntpulltoreacthttpsgithubcommentionappmntpulltoreact&quot;&gt;&lt;a href=&quot;https://github.com/mentionapp/mntpulltoreact&quot;&gt;mntpulltoreact&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mentionapp/mntpulltoreact/master/README/mention-example.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tkrubberindicatorhttpsgithubcomtbxarktkrubberindicator&quot;&gt;&lt;a href=&quot;https://github.com/TBXark/TKRubberIndicator&quot;&gt;TKRubberIndicator&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/TBXark/TKRubberIndicator/master/TKRubberIndicator/rubberindicator.gif&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tyalertcontrollerhttpsgithubcom12207480tyalertcontroller&quot;&gt;&lt;a href=&quot;https://github.com/12207480/TYAlertController&quot;&gt;TYAlertController&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/12207480/TYAlertController/master/screenshot/TYAlertControllerDemo.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;yfstartviewhttpsgithubcomyeziaheheyfstartview&quot;&gt;&lt;a href=&quot;https://github.com/yeziahehe/YFStartView&quot;&gt;YFStartView&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7xkvt5.com1.z0.glb.clouddn.com/github/YFStartViewbuttom.gif&quot; alt=&quot;GIFImage&quot; /&gt;
&lt;img src=&quot;http://7xkvt5.com1.z0.glb.clouddn.com/github/YFStartViewcenter.gif&quot; alt=&quot;GIFImage&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ttgemojiratehttpsgithubcomzekunyanttgemojirate&quot;&gt;&lt;a href=&quot;https://github.com/zekunyan/TTGEmojiRate&quot;&gt;TTGEmojiRate&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_screenshot2.gif&quot; alt=&quot;Screenshot&quot; /&gt;
&lt;img src=&quot;http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_IBExample.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;alertonboardinghttpsgithubcomphilippeboisneyalertonboarding&quot;&gt;&lt;a href=&quot;https://github.com/PhilippeBoisney/AlertOnboarding&quot;&gt;AlertOnboarding&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/PhilippeBoisney/AlertOnboarding/blob/master/screenshot.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;htytextfieldhttpsgithubcomhantonhtytextfield&quot;&gt;&lt;a href=&quot;https://github.com/hanton/HTYTextField&quot;&gt;HTYTextField&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/hanton/HTYTextField/blob/master/screenshot/HTYTextField.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mevhorizontalcontactshttpsgithubcommanuelescrigmevhorizontalcontacts&quot;&gt;&lt;a href=&quot;https://github.com/manuelescrig/MEVHorizontalContacts&quot;&gt;MEVHorizontalContacts&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1849990/15137846/645a0d18-168c-11e6-96e2-651d8f8de3b0.gif&quot; alt=&quot;MEVHorizontalContacts&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;preview-transitionhttpsgithubcomramotionpreview-transition&quot;&gt;&lt;a href=&quot;https://github.com/Ramotion/preview-transition&quot;&gt;preview-transition&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Ramotion/preview-transition/blob/master/preview.gif&quot; alt=&quot;PreviewTransition&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;expanding-collectionhttpsgithubcomramotionexpanding-collection&quot;&gt;&lt;a href=&quot;https://github.com/Ramotion/expanding-collection&quot;&gt;expanding-collection&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Ramotion/expanding-collection/blob/master/preview.gif&quot; alt=&quot;PreviewTransition&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tween-controllerhttpsgithubcomdaltonclaybrooktween-controller&quot;&gt;&lt;a href=&quot;https://github.com/daltonclaybrook/tween-controller&quot;&gt;tween-controller&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/daltonclaybrook/tween-controller/master/example.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mevfloatingbuttonhttpsgithubcommanuelescrigmevfloatingbutton&quot;&gt;&lt;a href=&quot;https://github.com/manuelescrig/MEVFloatingButton&quot;&gt;MEVFloatingButton&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1849990/13462466/db001be6-e087-11e5-92a1-79c8ecefb715.gif&quot; alt=&quot;MEVFloatingButton&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 12 Jun 2016 17:30:00 +0800</pubDate>
        <link>http://DavidWangTM.github.io/2016/06/12/ios_animation_introduction/</link>
        <guid isPermaLink="true">http://DavidWangTM.github.io/2016/06/12/ios_animation_introduction/</guid>
        
        <category>ios</category>
        
        
      </item>
    
  </channel>
</rss>
